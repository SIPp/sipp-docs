<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "http://apache.org/forrest/dtd/document-v12.dtd">
<document> 
  <header> 
    <title>SIPp</title> 
    <subtitle>Reference documentation v1.0</subtitle>
    <authors>
        <person name="Richard GAYRAUD [initial code]" email="richard_gayraud@users.sourceforge.net"/>
        <person name="Olivier JACQUES [code/documentation]" email="ojacques@users.sourceforge.net"/>
    </authors>
  </header> 
  <body> 
    <section>
      <title>Foreword</title>
      <p>SIPp is a performance testing tool for the SIP protocol. It includes a
      few basic SipStone user agent scenarios (UAC and UAS) and establishes and
      releases multiple calls with the INVITE and BYE methods. It can also reads
      XML scenario files describing any performance testing configuration. It
      features the dynamic display of statistics about running tests (call rate,
      round trip delay, and message statistics), periodic CSV statistics dumps,
      TCP and UDP over multiple sockets or multiplexed with retransmission
      management, regular expressions and variables in scenario files, and
      dynamically adjustable call rates.</p>
      <p>SIPp can be used to test many real SIP equipements like SIP proxies,
      B2BUAs, SIP media servers, SIP/x gateways, SIP PBX, ... It is also very
      useful to emulate thousands of user agents calling your SIP system. </p>
      <p><strong>Want to see it?</strong></p>
      <p>Here is a screenshot</p>
      <p><img src="images/sipp-01.jpg" alt="SIPp screenshot" /></p>
      <p>And here is a video (Windows Media Player 9 codec or above required) of
      SIPp in action:</p>
      <p><icon src="images/wmv.gif" alt="wmv" /><link href="images/sipp-01.wmv">sipp-01.wmv</link></p>
    </section>
    <section><title>Installation</title>
        <section>
          <title>Getting SIPp</title>
           <p>SIPp is released under the <fork
           href="http://www.gnu.org/copyleft/gpl.html">GNU GPL license</fork>.
           All the terms of the license apply. It is provided to the SIP
           community by <fork href="http://www.hp.com">Hewlett-Packard</fork>
           engineers in hope it can be useful.</p> <p>We receive some support
           from our company to work on this tool freely, but <strong>HP does not
           provide any support nor warranty concerning SIPp.</strong></p>
            </section>
        <section><title>Stable release</title>
            <p>Like many other "open source" projects, there are two versions of
            SIPp: a stable and unstable release. Stable release: before being
            labelled as "stable", a SIPp release is thoroughly tested. So you
            can be confident that all mentionned features will work :) </p>
            <note>Use the stable release for your everyday use and if you are
            not blocked by a specific feature present in the "unstable release"
            (see below).</note> <p><fork
            href="http://sourceforge.net/project/showfiles.php?group_id=104305">SIPp
            stable download page</fork></p>
            </section>
        <section><title>Unstable release</title>
            <p>Unstable release: every new features and bug fixes are checked in
            <fork href="http://cvs.sourceforge.net/viewcvs.py/sipp/sipp/">SIPp's
            CVS</fork> repository as soon as they are available. Every night, an
            automatic extraction is done and the source code of this release is
            made available. </p>
            <note> Use the unstable release if you absolutely need a bug fix or
            a feature that is not in the stable release. </note>
            <p><fork href="http://sipp.sourceforge.net/snapshots/">SIPp "unstable" download page</fork></p>
        </section>
        <section><title>Available platforms</title>
            <p>SIPp is available on almost all UNIX platforms: HPUX, Tru64,
            Linux (RedHat, Debian, FreeBSD), Solaris/SunOS.</p>
            <p>A Windows port has been contributed. You can now compile SIPp under
            Cygwin. A binary package with a Windows installer is also available. 
            Check <fork href="http://sipp.sourceforge.net/snapshots/">the
            snapshot page</fork> to download it and run SIPp under Windows.</p>
            </section> 
        <section><title>Installing SIPp</title>
          <ul>
          <li>On Linux, SIPp is provided in the form of source code. You will need to
            compile SIPp to actually use it. The good news is that there are
            <strong>no depencies to install</strong>. Building SIPp is straight
            forward.</li></ul>
<source># gunzip sipp-xxx.tar.gz
# tar -xvf sipp-xxx.tar
# cd sipp
# make
</source>
          <ul><li>On Windows, SIPp is provided both with the source and the pre-compiled 
          executable. Just execute the installer to have SIPp installed.</li>
          </ul>
        </section>     
        <section><title>Increasing File Descriptors Limit</title>
        <p>If your system does not supports enough file descriptors, 
        you may experience problems when using the TCP mode with many simultaneous calls. 
        Depending on the operating system you use, different procedures 
        allow to increase the maximum number of file descriptors:</p>
        <ul>
            <li><p>On Linux 2.4 kernels the default number of file descriptors can 
            be increased by modifying the <code>/etc/security/limits.conf</code> 
            and the <code>/etc/pam.d/login</code> file. </p>
            <p>Open the <code>/etc/security/limits.conf</code> file and add the following lines:</p>
<source>soft nofile 1024
hard nofile 65535</source>
            <p>Open the <code>/etc/pam.d/login</code> and add the following line</p>
<source>session required /lib/security/pam_limits.so</source>
            <p>The system file descriptor limit is set in the <code>/proc/sys/fs/file-max</code> file. 
            The following command will increase the file descriptor limit:</p>
<source>echo 65535> /proc/sys/fs/file-max</source>
            <p>To increase the number of file descriptors to its maximum limit 
            (65535) set in the <code>/etc/security/limits.conf</code> file, type:</p>
<source>ulimit -n unlimited</source>
            <p>Logout then login again to make the changes effective.</p>
            </li>
            <li><p>On HP-UX systems the default number of file descriptors 
            can be increased by modifying the system configuration with the sam utility. 
            In the Kernel Configuration menu, select Configurable parameters, 
            and change the following attributes:</p> 
<source>maxfiles : 4096
maxfiles_lim : 4096
nfiles : 4096
ninode : 4096
max_thread_proc : 4096
nkthread : 4096</source>
            </li>
          </ul>
        </section>
    </section>
   <section><title>Using SIPp</title>
        <section>
          <title>Main features</title>
            <p>SIPp allows to generate one or many SIP calls to one remote
            system. The tool is started from the command line. In this example,
            two SIPp are started in front of each other to demonstrate SIPp
            capabilities.</p>
            <p>Run sipp with embedded server (uas) scenario:</p>
            <source># ./sipp -sn uas</source>
            <p>On the same host, run sipp with embedded client (uac) scenario</p>
            <source># ./sipp -sn uac 127.0.0.1</source>
        </section>     
        <section>
          <title>Integrated scenarios</title>
            <p>Integrated scenarios? Yes, there are scenarios that are embedded
            in SIPp executable. While you can create your own custom SIP
            scenarios (see <link href="#xmlsyntax">how to create your own XML
            scenarios</link>), a few basic (yet useful) scenarios are available
            in SIPp executable.</p>
            <section>
              <title>UAC</title>
                <p>Scenario file: <link href="uac.xml.html">uac.xml</link> (<link href="uac.xml">original XML file</link>)</p>
                <source>SIPp UAC            Remote
    |(1) INVITE         |
    |------------------&gt;|
    |(2) 100 (optional) |
    |&lt;------------------|
    |(3) 180 (optional) |
    |&lt;------------------|
    |(4) 200            |
    |&lt;------------------|
    |(5) ACK            |
    |------------------&gt;|
    |                   |
    |(6) PAUSE          |
    |                   |
    |(7) BYE            |
    |------------------&gt;|
    |(8) 200            |
    |&lt;------------------|
</source>
            </section>
            <section>
              <title>UAS</title>
                <p>Scenario file: <link href="uas.xml.html">uas.xml</link> (<link href="uas.xml">original XML file</link>)</p>
                <source>Remote              SIPp UAS
    |(1) INVITE         |
    |------------------&gt;|
    |(2) 180            |
    |&lt;------------------|
    |(3) 200            |
    |&lt;------------------|
    |(4) ACK            |
    |------------------&gt;|
    |                   |
    |(5) PAUSE          |
    |                   |
    |(6) BYE            |
    |------------------&gt;|
    |(7) 200            |
    |&lt;------------------|
</source>
            </section>
            <section>
              <title>regexp</title>
                <p>Scenario file: <link href="regexp.xml.html">regexp.xml</link> (<link href="regexp.xml">original XML file</link>)</p>
                <p>This scenario, which behaves as an UAC is explained in greater details in <link href="#actions">this section</link>.</p>
                <source>SIPp regexp         Remote
    |(1) INVITE         |
    |------------------&gt;|
    |(2) 100 (optional) |
    |&lt;------------------|
    |(3) 180 (optional) |
    |&lt;------------------|
    |(4) 200            |
    |&lt;------------------|
    |(5) ACK            |
    |------------------&gt;|
    |                   |
    |(6) PAUSE          |
    |                   |
    |(7) BYE            |
    |------------------&gt;|
    |(8) 200            |
    |&lt;------------------|
</source>
            </section>
            <anchor id="ThreePCC" /><section>
              <title>3PCC</title>
                <p>3PCC stands for 3rd Party Call Control. 3PCC is described in 
                <link href="http://www.ietf.org/rfc/rfc3725.txt">RFC 3725</link>.
                While this feature was first developped to allow 3PCC like scenarios, 
                it can also be used for every case where you would need one SIPp to talk
                to several remotes.</p>
                <p>In order to keep SIPp simple (remember, it's a test tool!),
                one SIPp instance can only talk to one remote. Which is an issue
                in 3PCC call flows, like call flow I (SIPp beeing a controller):</p>
                <source>             A              Controller               B
             |(1) INVITE no SDP  |                   |
             |&lt;------------------|                   |
             |(2) 200 offer1     |                   |
             |------------------&gt;|                   |
             |                   |(3) INVITE offer1  |
             |                   |------------------&gt;|
             |                   |(4) 200 OK answer1 |
             |                   |&lt;------------------|
             |                   |(5) ACK            |
             |                   |------------------&gt;|
             |(6) ACK answer1    |                   |
             |&lt;------------------|                   |
             |(7) RTP            |                   |
             |.......................................|
</source>
                <p>Scenario file: <link href="3pcc-A.xml.html">3pcc-A.xml</link> (<link href="3pcc-A.xml">original XML file</link>)</p>
                <p>Scenario file: <link href="3pcc-B.xml.html">3pcc-B.xml</link> (<link href="3pcc-B.xml">original XML file</link>)</p>
                <p>Scenario file: <link href="3pcc-C-A.xml.html">3pcc-C-A.xml</link> (<link href="3pcc-C-A.xml">original XML file</link>)</p>
                <p>Scenario file: <link href="3pcc-C-B.xml.html">3pcc-C-B.xml</link> (<link href="3pcc-C-B.xml">original XML file</link>)</p>
                <p>The 3PCC feature in SIPp allows to have two SIPp instances
                launched and synchronised together. If we take the example of 
                call flow I, one SIPp instance will take care of the dialog with
                remote A (this instance is called 3PCC-C-A for 3PCC-Controller-A-Side) 
                and another SIPp instance will take care of the dialog with remote B 
                (this instance is called 3PCC-C-B for 3PCC-Controller-B-Side).</p>
                <p>The 3PCC call flow I will, in reality, look like this
                (Controller has been divided in two SIPp instances):</p>
                <source>
             A             Controller A         Controller B            B
             |(1) INVITE no SDP  |                  |                   |
             |&lt;------------------|                  |                   |
             |(2) 200 offer1     |                  |                   |
             |------------------>|                  |                   |
             |                sendCmd  (offer1)     |                   |
             |                   |-----------------&gt;|                   |
             |                   |               recvCmd                |
             |                   |                  |(3) INVITE offer1  |
             |                   |                  |------------------&gt;|
             |                   |                  |(4) 200 OK answer1 |
             |                   |                  |&lt;------------------|
             |                   |               sendCmd                |
             |                   |     (answer1)    |                   |
             |                   |&lt;-----------------|                   |
             |                 recvCmd              |(5) ACK            |
             |                   |                  |------------------&gt;|
             |(6) ACK answer1    |                  |                   |
             |&lt;------------------|                  |                   |
             |(7) RTP            |                  |                   |
             |..........................................................|
</source>
                <p>As you can see, we need to pass informations
                between both sides of the controller. SDP "offer1" is provided
                by A in message (2) and needs to be sent to B side in message (3). 
                This mechanism is implemented 
                in the scenarios through the &lt;<link href="#sendCmd">sendCmd</link>&gt; command. This:</p>
<source>&lt;sendCmd&gt;
  &lt;![CDATA[
    Call-ID: [call_id]
    [$1]

   ]]&gt;
&lt;/sendCmd&gt;
</source>
                <p>Will send a "command" to the twin SIPp instance. Note that including
                the Call-ID is mandatory in order to correlate the commands to
                actual calls. In the same manner, this:</p>
<source>&lt;recvCmd&gt;
  &lt;action
     &lt;ereg regexp="Content-Type:.*"
           search_in="msg"
           assign_to="2"/&gt;
  &lt;/action&gt;
&lt;/recvCmd&gt;
</source>
                <p>Will receive a "command" from the twin SIPp instance. 
                Using the <link href="#regexp">regular expression</link> mechanism, 
                the content is retrieved
                and stored in a call variable ($2 in this case), ready to be
                reinjected</p>
<source>  &lt;send&gt;
    &lt;![CDATA[

      ACK sip:[service]@[remote_ip]:[remote_port] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port]
      From: sipp &lt;sip:sipp@[local_ip]:[local_port]&gt;;tag=[call_number]
      To: sut &lt;sip:[service]@[remote_ip]:[remote_port]&gt;[peer_tag_param]
      Call-ID: [call_id]
      CSeq: 1 ACK
      Contact: sip:sipp@[local_ip]:[local_port]
      Max-Forwards: 70
      Subject: Performance Test
      [$2]

    ]]&gt;
  &lt;/send&gt;
</source>                
                <p>In other words, <link href="#sendCmd">sendCmd</link> and <link href="#recvCmd">recvCmd</link> can be seen as synchronization points
                between two SIPp instances, with the ability to pass parameters
                between each other.</p>
                <p>Another scenario that has been reported to be do-able with the
                3PCC feature is the following:</p>
                <ul>
                  <li>A calls B. B answers. B and A converse</li>
                  <li>B calls C. C answers. C and B converse</li>
                  <li>B "REFER"s A to C and asks to replace A-B call with B-C call.</li>
                  <li>A accepts. A and C talk. B drops out of the calls.</li>
                </ul>
            </section>
        </section>
        <section><title>Traffic control</title>
        <p>SIPp generates SIP traffic according to the scenario specified. You
        can control the number of calls (scenario) that are started per second.
        This can be done either: </p>        
        <ul>
            <li>Interactively, by pressing keys on the keyboard</li>
            <ul>
                <li>'+' key to increase call rate by 1</li>
                <li>'-' key to decrease call rate by 1</li>
                <li>'*' key to increase call rate by 10</li>
                <li>'/' key to increase call rate by 10</li>
            </ul>
            <li>At starting time, by specifying parameters on the command line:</li>
                <ul>
                    <li>"-r" to specify the call rate in number of calls per seconds</li>
                    <li>"-rp" to specify the "<strong>r</strong>ate <strong>p</strong>eriod" 
                    in milliseconds for the call rate (default is 1000ms/1sec). 
                    This allows you to have n calls every m milliseconds (by using <code>-r n -rp m</code>).
                        <note>Example: run SIPp at 7 calls every 2 seconds (3.5 calls per second)</note>
                        <source>./sipp -sn uac -r 7 -rp 2000 127.0.0.1</source>
                    </li>
                </ul>
        </ul>
        <p>You can also <strong>pause</strong> the traffic by pressing the 'p' key. 
        SIPp will stop placing new calls and wait until all current calls go to their end. 
        You can <strong>resume</strong> the traffic by pressing 'p' again.</p>
        <p>To <strong>quit</strong> SIPp, press the 'q' key. 
        SIPp will stop placing new calls and wait until all current calls go to their end.
        SIPp will then exit.</p>
        <note><strong>TIP:</strong> you can place a defined number of calls and
        have SIPp exit when this is done. Use the <code>-m</code> option on the
        command line.</note>
        </section>
        <section><title>Running SIPp in background</title>
          <p>SIPp can be launched in background mode (<code>-bg</code> command
          line option).</p>
          <p>By doing so, SIPp will be detached from the current terminal and run
          in background. The PID of the SIPp process is provided. If you didn't specified a number of calls to execute
          with the <code>-m</code> option, SIPp will run forever.</p>
          <p>There is a mechanism implemented to stop SIPp smoothly. The command
          <code>kill -SIGUSR1 [SIPp_PID]</code> will instruct SIPp to stop placing
          any new calls and finish all ongoing calls before exiting.</p>
        </section>
        <anchor id="xmlsyntax" /><section><title>Create your own XML scenarios</title>
            <p>Of course embedded scenarios will not be enough. So it's time to
            create your own scenarios. A SIPp scenario is written in XML
            (although there are currently no DTD to help you write SIPp
            scenarios). A scenario will always start with:</p>
            <source>&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;
&lt;scenario name="Basic Sipstone UAC"&gt;
</source>
            <p>And end with:</p>
<source>&lt;/scenario&gt;</source>
            <p>Easy, huh? Ok, now let's see what can be put inside. You are not
            obliged to read the whole table now! Just go in the next section for
            an example.</p>
            <table>
                <caption>List of commands with their attributes</caption>
                <tr>
                    <th>Command</th>
                    <th>Attribute(s)</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td><anchor id="send"/><strong>&lt;send&gt;</strong></td>
                    <td>retrans</td>
                    <td>Used for UDP transport only: it specifies the interval,
                    in milliseconds, between each retransmission. There is a
                    total of 7 retransmissions before aborting the call. </td>
                    <td><code>&lt;send retrans="500"&gt;</code>: will retransmit the message every 500 milliseconds.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>start_rtd</td>
                    <td>Specifies the message on which SIPp starts the "<strong>R</strong>esponse <strong>T</strong>ime <strong>D</strong>uration" timer.
                    It is used to compute time between message exchanges. 
                    By default, start_rtd is set on the first message of the scenario.</td>
                    <td><code>&lt;send start_rtd="true"&gt;</code>: the timer will start when the enclosed message is sent.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>rtd</td>
                    <td>Specifies the message on which SIPp stops the "<strong>R</strong>esponse <strong>T</strong>ime <strong>D</strong>uration" timer.
                    By default, rtd is set on the last message of the scenario.</td>
                    <td><code>&lt;send rtd="true"&gt;</code>: the timer will stop when the enclosed message is sent.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>lost</td>
                    <td>Emulate packet lost. The value is specified as a percentage.</td>
                    <td><code>&lt;send lost="10"&gt;</code>: 10% of the message sent are actually not sent :).</td>
                </tr>            
                <tr>
                    <td><anchor id="recv"/><strong>&lt;recv&gt;</strong></td>
                    <td>response</td>
                    <td>Indicates what SIP message code is expected.</td>
                    <td><code>&lt;recv response="200"&gt;</code>: SIPp will expect a SIP message with code "200".</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>request</td>
                    <td>Indicates what SIP message request is expected.</td>
                    <td><code>&lt;recv response="ACK"&gt;</code>: SIPp will expect an "ACK" SIP message.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>optional</td>
                    <td>Indicates if the message to receive is optional. In case of an optional
                    message and if the message is actually received, it is not seen as a unexpected message.</td>
                    <td><code>&lt;recv response="100" optional="true"&gt;</code>: The 100 SIP message can be received without 
                    being considered as "unexpected".</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>rrs</td>
                    <td><strong>R</strong>ecord <strong>R</strong>oute <strong>S</strong>et. if this attribute is set to "true",
                    then the "Record-Route:" header of the message received is stored and can be recalled using the <strong>[routes]</strong> keyword.</td>
                    <td><code>&lt;recv response="100" rrs="true"&gt;</code>.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>start_rtd</td>
                    <td>Specifies the message on which SIPp starts the "<strong>R</strong>esponse <strong>T</strong>ime <strong>D</strong>uration" timer.
                    It is used to compute time between message exchanges. 
                    By default, start_rtd is set on the first message of the scenario.</td>
                    <td><code>&lt;recv start_rtd="true"&gt;</code>: the timer will start when the enclosed message is sent.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>rtd</td>
                    <td>Specifies the message on which SIPp stops the "<strong>R</strong>esponse <strong>T</strong>ime <strong>D</strong>uration" timer.
                    By default, rtd is set on the last message of the scenario.</td>
                    <td><code>&lt;recv rtd="true"&gt;</code>: the timer will stop when the enclosed message is sent.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>lost</td>
                    <td>Emulate packet lost. The value is specified as a percentage.</td>
                    <td><code>&lt;recv lost="10"&gt;</code>: 10% of the message received are thrown away.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>action</td>
                    <td>Specify an action when receiving the message. See  <link href="#actions">Actions section</link> for possible actions.</td>
                    <td>Example of a "regular expression" action:<source>&lt;recv response="200"&gt;
 &lt;action&gt;
  &lt;ereg regexp="([0-9]{1,3}\.){3}[0-9]{1,3}:[0-9]*"
    search_in="msg"
    check_it="true"
    assign_to="1,2"/&gt;
  &lt;/action&gt;
 &lt;/recv&gt;</source></td>
                </tr>
                <tr>
                    <td><anchor id="sendCmd"/><strong>&lt;sendCmd&gt;</strong></td>
                    <td>&lt;![CDATA[]]&gt;</td>
                    <td>Content to be sent to the twin <link href="#ThreePCC">3PCC</link> SIPp instance. The Call-ID must be included in the CDATA.</td>
                    <td><source>&lt;sendCmd&gt;
  &lt;![CDATA[
    Call-ID: [call_id]
    [$1]

   ]]&gt;
&lt;/sendCmd&gt;</source></td>
                </tr>            
                <tr>
                    <td><anchor id="recvCmd"/><strong>&lt;recvCmd&gt;</strong></td>
                    <td>action</td>
                    <td>Specify an action when receiving the command. See  <link href="#actions">Actions section</link> for possible actions.</td>
                    <td>Example of a "regular expression" to retrieve what has been send by a sendCmd command:<source>&lt;recvCmd&gt;
  &lt;action
     &lt;ereg regexp="Content-Type:.*"
           search_in="msg"
           assign_to="2"/&gt;
  &lt;/action&gt;
&lt;/recvCmd&gt;</source></td>
                </tr>            
                <tr>
                    <td><strong>&lt;pause&gt;</strong></td>
                    <td>milliseconds</td>
                    <td>Specify the pause delay, in milliseconds. When this delay is not set, the value of the <code>-d</code> command
                    line parameter is used.</td>
                    <td><code>&lt;pause milliseconds="5000"&gt;</code>: pause the scenario for 5 seconds.</td>
                </tr>            
                <tr>
                    <td><strong>&lt;ResponseTimeRepartition&gt;</strong></td>
                    <td>value</td>
                    <td>Specify the intervals, in milliseconds, used to distribute the values of response times.</td>
                    <td><code>&lt;ResponseTimeRepartition value="10, 20,
                    30"/&gt;</code>: response time values are distributed
                    between 0 and 10ms, 10 and 20ms, 20 and 30ms, 30 and
                    beyond.</td>
                </tr>            
                <tr>
                    <td><strong>&lt;CallLengthRepartition&gt;</strong></td>
                    <td>value</td>
                    <td>Specify the intervals, in milliseconds, used to distribute the values of the call length measures.</td>
                    <td><code>&lt;CallLengthRepartition value="10, 20,
                    30"/&gt;</code>: call length values are distributed between
                    0 and 10ms, 10 and 20ms, 20 and 30ms, 30 and beyond.</td>
                </tr>
            </table>
            <p>As you can see, there are not so many commands: send, recv, sendCmd, recvCmd,
            pause, ResponseTimeRepartition and CallLengthRepartition. To make
            things even clearer, nothing is better than an example...</p>
            <section><title>Structure of client (UAC like) XML scenarios</title>
            <p>A client scenario is a scenario that starts with a "send" command. So let's start:</p>
            <source>&lt;scenario name="Basic Sipstone UAC"&gt;
  &lt;send&gt;
    &lt;![CDATA[
    
      INVITE sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong> SIP/2.0
      Via: SIP/2.0/<strong>[transport]</strong> <strong>[local_ip]</strong>:<strong>[local_port]</strong>
      From: sipp &lt;sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>&gt;;tag=<strong>[call_number]</strong>
      To: sut &lt;sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong>&gt;
      Call-ID: <strong>[call_id]</strong>
      Cseq: 1 INVITE
      Contact: sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>
      Max-Forwards: 70
      Subject: Performance Test
      Content-Type: application/sdp
      Content-Length: 136

      v=0
      o=user1 53655765 2353687637 IN IP4 127.0.0.1
      s=-
      t=0 0
      c=IN IP4 <strong>[media_ip]</strong>
      m=audio <strong>[media_port]</strong> RTP/AVP 0
      a=rtpmap:0 PCMU/8000


    ]]&gt;
  &lt;/send&gt;</source>
            <p>Inside the "send" command, you have to enclose your SIP message
            between the "&lt;![CDATA" and the "]]&gt;" tags. Everything between
            those tags is going to be sent toward the remote system. You may
            have noticed that there are strange keywords in the SIP message,
            like <strong>[service], [remote_ip], ...</strong>. Those keywords
            are used to indicate to SIPp that it has to do something with
            it.</p>
            <p>Here is the list:</p>
            <table>
                <caption>Keyword list</caption>
                <tr>
                    <th>Keyword</th>
                    <th>Default</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><strong>[service]</strong></td>
                    <td>service</td>
                    <td>Service field, as passed in the <strong><code>-s service_name</code></strong></td>
                </tr>
                <tr>
                    <td><strong>[remote_ip]</strong></td>
                    <td>-</td>
                    <td>Remote IP address, as passed on the command line.</td>
                </tr>
                <tr>
                    <td><strong>[remote_port]</strong></td>
                    <td>5060</td>
                    <td>Remote IP port, as passed on the command line.</td>
                </tr>
                <tr>
                    <td><strong>[transport]</strong></td>
                    <td>UDP</td>
                    <td>Depending on the value of <strong>-t</strong> parameter, this will take the values "UDP" or "TCP".</td>
                </tr>
                <tr>
                    <td><strong>[local_ip]</strong></td>
                    <td>Primary host IP address</td>
                    <td>Will take the value of <strong>-i</strong> parameter.</td>
                </tr>
                <tr>
                    <td><strong>[local_port]</strong></td>
                    <td>Random</td>
                    <td>Will take the value of <strong>-p</strong> parameter.</td>
                </tr>
                <tr>
                    <td><strong>[call_number]</strong></td>
                    <td>-</td>
                    <td>Index. The call_number starts from "1" and is incremented by 1 for each call.</td>
                </tr>
                <tr>
                    <td><strong>[call_id]</strong></td>
                    <td>-</td>
                    <td>A call_id identifies a call and is generated by SIPp for each new call. <strong>In client mode, it is mandatory
                    to use the value generated by SIPp in the "Call-ID" header.</strong> Otherwise, SIPp will not recognise
                    the answer to the message sent as being part of an existing call.</td>
                </tr>
                <tr>
                    <td><strong>[media_ip]</strong></td>
                    <td>-</td>
                    <td>Depending on the value of <strong>-mi</strong> parameter, it is the local IP address for RTP echo.</td>
                </tr>
                <tr>
                    <td><strong>[media_port]</strong></td>
                    <td>-</td>
                    <td>Depending on the value of <strong>-mp</strong> parameter, it set the local RTP echo port number. Default
                      is none. RTP/UDP packets received on thatport are echoed to their sender.</td>
                </tr>
                <tr>
                    <td><strong>[last_*]</strong></td>
                    <td>-</td>
                    <td>The '[last_*]' keyword is replaced automatically by the
                    specified header if it was present in the last message
                    received (except if it was a retransmission). If the header
                    was not present or if no message has been received, the
                    '[last_*]' keyword is discarded, and all bytes until the end
                    of the line are also discarded. If the specified header was
                    present several times in the message, all occurences are
                    concatenated (CRLF separated) to be used in place of the
                    '[last_*]' keyword.</td>
                </tr>
                <tr>
                    <td><strong>[field0-n]</strong></td>
                    <td>-</td>
                    <td>Used to inject values from an external CSV file. See
                    <link href="#inffile">"Injecting values from an external CSV
                    during calls"</link> section.</td>
                </tr>
                <tr>
                    <td><strong>[$n]</strong></td>
                    <td>-</td>
                    <td>Used to inject the value of call variable number n. See "<link href="#actions">Actions</link>" section</td>
                </tr>
            </table>
            <p>Now that the INVITE message is sent, SIPp can wait for an answer by using the "<link href="#recv">recv</link>" command.</p>
<source>  &lt;recv response="100"&gt; optional="true"
  &lt;/recv&gt;

  &lt;recv response="180"&gt; optional="true"
  &lt;/recv&gt;

  &lt;recv response="200"&gt;
  &lt;/recv&gt;</source>
            <p>As you can see, 100 and 180 messages are optional, and 200 is mandatory. 
            <strong>In a "recv" sequence, there must be one mandatory message</strong>.</p>
            <p>Now, let's send the ACK:</p>
<source>  &lt;send&gt;
    &lt;![CDATA[

      ACK sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong> SIP/2.0
      Via: SIP/2.0/<strong>[transport]</strong> <strong>[local_ip]</strong>:<strong>[local_port]</strong>
      From: sipp &lt;sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>&gt;;tag=<strong>[call_number]</strong>
      To: sut &lt;sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port</strong>]&gt;<strong>[peer_tag_param]</strong>
      Call-ID: <strong>[call_id]</strong>
      Cseq: 1 ACK
      Contact: sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>
      Max-Forwards: 70
      Subject: Performance Test
      Content-Length: 0

    ]]&gt;
  &lt;/send&gt;</source>
            <p>We can also insert a pause. The scenario will wait for 5 seconds at this point.</p>
<source>  &lt;pause milliseconds="5000"/&gt;</source>
            <p>And finish the call by sending a BYE and expecting the 200 OK:</p>
<source>    &lt;send retrans="500"&gt;
     &lt;![CDATA[

      BYE sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong> SIP/2.0
      Via: SIP/2.0/<strong>[transport] [local_ip]</strong>:<strong>[local_port]</strong>
      From: sipp  &lt;sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>&gt;;tag=<strong>[call_number]</strong>
      To: sut  &lt;sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong>&gt;<strong>[peer_tag_param]</strong>
      Call-ID: <strong>[call_id]</strong>
      Cseq: 2 BYE
      Contact: sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>
      Max-Forwards: 70
      Subject: Performance Test
      Content-Length: 0

    ]]&gt;
   &lt;/send&gt;

   &lt;recv response="200"&gt;
   &lt;/recv&gt;</source>
            <p>And this is the end of the scenario:</p>
<source>&lt;/scenario&gt;</source>
            <p>As you can see, creating your own SIPp scenarios is not a big deal. 
            If you want to see other examples, use the <code>-sd</code> parameter
            on the command line to display embedded scenarios.</p>
            </section>
            <section><title>Structure of server (UAS like) XML scenarios</title>
            <p>A server scenario is a scenario that starts with a "<link href="#recv">recv</link>" command. 
            The syntax and the list of available commands is the same as for
            "client" scenarios.</p>
            <p>But you are more likely to use [last_*] keywords in those server
            side scenarios. For example, a UAS example will look like:</p>
<source>  &lt;recv request="INVITE"&gt;
  &lt;/recv&gt;

  &lt;send&gt;
    &lt;![CDATA[

      SIP/2.0 180 Ringing
      <strong>[last_Via:]</strong>
      <strong>[last_From:]</strong>
      <strong>[last_To:]</strong>;tag=<strong>[call_number]</strong>
      <strong>[last_Call-ID:]</strong>
      <strong>[last_CSeq:]</strong>
      Contact: &lt;sip:<strong>[local_ip]</strong>:<strong>[local_port]</strong>;transport=<strong>[transport]</strong>&gt;
      Content-Length: 0

    ]]&gt;
  &lt;/send&gt;</source>
            <p>The answering message, 180 Ringing in this case, is built
            with the content of headers received in the INVITE message.</p>
            </section>
            <anchor id="actions" /><section><title>Actions</title>
              <p>In a "<link href="#recv">recv</link>" or "<link href="#recvCmd">recvCmd</link>" command, you have the possibility to
              execute an action. The only possible action at the moment
              is a "regular expression".</p>
                <anchor id="regexp" /><section><title>Regular expressions</title>
                  <p>Using regular expressions in SIPp allows to</p>
                  <ul>
                     <li>Extract content of a SIP message or a SIP header and
                     store it for future usage (called re-injection)</li>
                     <li>Check that a part of a SIP message or of an header 
                     is matching an expected expression</li>
                  </ul>
                  <p>Regular expressions used in SIPp are defined per 
                  <link href="http://www.opengroup.org/onlinepubs/007908799/xbd/re.html">
                  Posix Extended standard (POSIX 1003.2)</link>. If you want to
                  learn how to write regular expressions, I will recommend 
                  this <link href="http://analyser.oli.tudelft.nl/regex/index.html.en">
                  regexp tutorial</link>.</p>
                  <p>Here is the syntax of the regexp action:</p>
                  <table>
                      <caption>regexp action syntax</caption>
                      <tr>
                          <th>Keyword</th>
                          <th>Default</th>
                          <th>Description</th>
                      </tr>
                      <tr>
                          <td>regexp</td>
                          <td>None</td>
                          <td>Contains the regexp to use for matching the 
                          received message or header. MANDATORY.</td>
                      </tr>
                      <tr>
                          <td>search_in</td>
                          <td>msg</td>
                          <td>can have 2 values: "msg" (try to match against 
                          the entire message) or "hdr" (try to match against a specific SIP header).</td>
                      </tr>
                      <tr>
                          <td>header</td>
                          <td>None</td>
                          <td>Header to try to match against. Only used when 
                          the search_in tag is set to hdr. MANDATORY IF 
                          search_in is equal to hdr.</td>
                      </tr>
                      <tr>
                          <td>check_it</td>
                          <td>false</td>
                          <td>if set to true, the call is marked as failed if 
                          the regexp doesn't match.</td>
                      </tr>
                      <tr>
                          <td>assign_to</td>
                          <td>None</td>
                          <td>contain the variable id (integer) or a list of 
                          variable id which will be used to store the 
                          result of the matching process between the regexp 
                          and the message. This variable can be re-used at 
                          a later time in the scenario using '[$n]' syntax 
                          where n is the variable id.</td>
                      </tr>
                  </table>
                  <p>Note that you can have several regular expressions
                  in one action.</p>
                  <p>The following example is used to:</p>
                  <ul>
                    <li>First action:</li>
                    <ul>
                      <li>Extract the first IPv4 address of the received SIP message</li>
                      <li>Check that we could actually extract this IP address (otherwise
                      call will be marked as failed)</li>
                      <li>Assign the extracted IP address to call variables 1
                      and 2.</li>
                    </ul>
                    <li>Second action:</li>
                    <ul>
                      <li>Extract the Contact: header of the received SIP message</li>
                      <li>Assign the extracted Contract: header to variable 6.</li>
                    </ul>
                  </ul>
                  <source>
&lt;recv response="200" start_rtd="true"&gt;
  &lt;action&gt;
    &lt;ereg regexp="([0-9]{1,3}\.){3}[0-9]{1,3}:[0-9]*" search_in="msg" check_it="true" assign_to="1,2" /&gt; 
    &lt;ereg regexp=".*" search_in="hdr" header="Contact:" check_it="true" assign_to="6" /&gt;
  &lt;/action&gt;
&lt;/recv&gt;
</source>
                </section>
            </section>
            <anchor id="inffile" /><section><title>Injecting values from an external CSV during calls</title>
                <p>You can use "<code>-inf file_name</code>" as a command line parameter
                to input values into the scenarios. The first line of the file should
                say whether the data is to be read in sequence (SEQUENTIAL) or random
                (RANDOM) order. Each line corresponds to one call and has one or more
                ';' delimited data fields and they can be referred as [field0], [field1], ... in the
                xml scenario file. Example:</p>
<source>SEQUENTIAL
#This line will be ignored
Sarah;sipphone32
Bob;sipphone12
#This line too
Fred;sipphone94</source>
                <p>Will be read in sequence (first call will use first line,
                second call second line). At any place where the keyword
                "[field0]" appears in the scenario file, it will be replaced by
                either "Sarah", "Bob" or "Fred" depending on the call. At any
                place where the keyword "[field1]" appears in the scenario file,
                it will be replaced by either "sipphone32" or "sipphone12" or
                "sipphone94" depending on the call. At the end of the file, SIPp
                will re-start from the beginning. The file is not limited in
                size.</p>
                <p>The CSV file can contain comment lines. A comment line is
                a line that starts with a "#".</p>
                <p>As a picture says more than 1000 words, here is one:</p>
                <p><img src="images/sipp-02.gif" alt="Field injection" /></p>
                <p>Think of the possibilities of this feature. They are huge.</p>
            </section>
        </section>
        <section><title>Screens</title>
            <p>Several screens are available to monitor SIP traffic. You can 
            change of screen by pressing 1, 2, 3 or 4 keys on the keyboard.</p>
            <ul>
                <li>Key '1': Scenario screen. It displays a call flow of
                the scenario as well as some important informations.
                <p><img src="images/sipp-03.jpg" alt="Scenario screen" /></p>
                </li>
                <li>Key '2': Statistics screen. It displays the main statistics
                counters. The "Cumulative" column gather all statistics, since
                SIPp has been launched. The "Periodic" column gives the statistic
                value for the period considered (specified by <code>-f frequency</code> command
                line parameter).
                <p><img src="images/sipp-04.jpg" alt="Statistics screen" /></p>
                </li>
                <li>Key '3': Repartition screen. It displays the distribution
                of response time and call length, as specified in the scenario.
                <p><img src="images/sipp-05.jpg" alt="Repartition screen" /></p></li>
                <li>Key '4': Variables screen. It displays informations on
                actions in scenario as well as scenario variable informations.
                <p><img src="images/sipp-06.jpg" alt="Variables screen " /></p></li>
            </ul>
        </section>
        <section><title>Transport modes</title>
            <p>SIPp has several transport modes. The default transport mode is 
            "UDP mono socket".</p>
            <section><title>UDP mono socket</title>
                <p>In UDP mono socket mode (<code>-u1</code> command line parameter),
                one IP/UDP socket is opened between SIPp and the remote. All calls
                are placed using this socket.</p>
                <note>This mode is generally used for emulating a relation
                between 2 SIP servers.</note>
            </section>
            <section><title>UDP multi socket</title>
                <p>In UDP multi socket mode (<code>-un</code> command line parameter),
                one IP/UDP socket is opened for each new call between SIPp and the remote.</p>
                <note>This mode is generally used for emulating user agents calling a SIP server.</note>
            </section>
            <section><title>TCP mono socket</title>
                <p>In TCP mono socket mode (<code>-t1</code> command line parameter),
                one IP/TCP socket is opened between SIPp and the remote. All calls
                are placed using this socket.</p>
                <note>This mode is generally used for emulating a relation between 2 SIP servers.</note>
            </section>
            <section><title>TCP multi socket</title>
                <p>In TCP multi socket mode (<code>-tn</code> command line parameter),
                one IP/TCP socket is opened for each new call between SIPp and the remote.</p>
                <note>This mode is generally used for emulating user agents calling a SIP server.</note>
            </section>
        </section>
        <section><title>Handling media with SIPp - RTP echo</title>
            <p>SIPp is originally a signalling plane traffic generator. There is a limited
            support of media (RTP).</p>
            <p>The "RTP echo" feature allows SIPp to listen to one local IP
            address and port (specified using <code>-mi</code> and
            <code>-mp</code> command line parameters) for RTP media. Everything
            that is received on this address/port is echoed back to the
            sender.</p>
            <p>This allows you to have a media channel opened even if no media
            can be sent from SIPp.</p>
        </section>
        <section><title>Exit codes</title>
            <p>To ease automation of testing, upon exit (on fatal error or when
            the number of asked calls (<code>-m</code> command line option) is
            reached, sipp exits with one of the following exit codes:</p>
            <ul>
                <li>0: All calls were successful</li>
                <li>1: At least one call failed</li>
                <li>99: Normal exit without calls processed</li>
                <li>-1: Fatal error</li>
            </ul>
            <p>Depending on the system that SIPp is running on, you can echo
            this exit code by using "<code>echo ?</code>" command.</p>
        </section>
        <section><title>Statistics</title>
            <section><title>Available counters</title>
                <p>The <code>-trace_stat</code> option dumps all statistics in
                the pid_scenario_name.csv file. The dump starts with one header line
                with all counters. All following lines are 'snapshots' of
                statistics counter given the statistics report frequency (-fd
                option). When SIPp exits, the last values of the statistics
                are also dumped in this file.</p>
                <p>This file can be easily imported in any spreadsheet
                application, like Excel.</p>
                <p>In counter names, (P) means 'Periodic' - since last statistic
                row and (C) means 'Cumulated' - since sipp was started.</p>
<anchor id="stats" /><p>Available statistics are:</p>
  <ul>
    <li>StartTime: 
    Date and time when the test has started.</li>
    <li>LastResetTime:
    Date and time when periodic counters where last reseted.</li>
    <li>CurrentTime:
    Date and time of the statistic row.</li>
    <li>ElapsedTime:
    Elapsed time.</li>
    <li>CallRate:
    Call rate (calls per seconds).</li>
    <li>IncomingCall:
    Number of incoming calls.</li>
    <li>OutgoingCall:
    Number of outgoing calls.</li>
    <li>TotalCallCreated:
    Number of calls created.</li>
    <li>CurrentCall:
    Number of calls currently ongoing.</li>
    <li>SuccessfulCall:
    Number of successful calls.</li>
    <li>FailedCall:
    Number of failed calls (all reasons).</li>
    <li>FailedCannotSendMessage:
    Number of failed calls because Sipp cannot send the
    message (transport issue).</li>
    <li>FailedMaxUDPRetrans:
    Number of failed calls because the maximum number of
    UDP retransmission attempts has been reached.</li>
    <li>FailedUnexpectedMessage:
    Number of failed calls because the SIP message received
    is not expected in the scenario.</li>
    <li>FailedCallRejected:
    Number of failed calls because of Sipp internal error.
    (a scenario sync command is not recognized or a scenario
    action failed or a scenario variable assignment failed).</li>
    <li>FailedCmdNotSent:
    Number of failed calls because of inter-Sipp
    communication error (a scenario sync command failed to
    be sent).</li>
    <li>FailedRegexpDoesntMatch:
    Number of failed calls because of regexp that doesn't
    match (there might be several regexp that don't match
    during the call but the counter is increased only by
    one).</li>
    <li>FailedRegexpHdrNotFound:
    Number of failed calls because of regexp with hdr    
    option but no matching header found.</li>
    <li>OutOfCallMsgs:
    Number of SIP messages received that cannot be associated
    to an existing call.</li>
    <li>AutoAnswered:
    Number of unexpected specific messages received for new Call-ID.
    The message has been automatically answered by a 200 OK
    Currently, implemented for 'PING' message only.</li>
    </ul>
            </section>
            <section><title>Importing statistics in spreadsheet applications</title>
                <section><title>Example: importation in Microsoft Excel</title>
                  <p>Here is a video (Windows Media Player 9 codec or above
                  required) on how to import CSV statistic files in Excel and
                  create a graph of failed calls over time.</p>
                  <p><icon src="images/wmv.gif" alt="wmv" /><link href="images/sipp-02.wmv">sipp-02.wmv</link></p>
                </section>
            </section>
        </section>
        <section><title>Error handling</title>
            <p>SIPp has advanced feature to handle errors and unexpected events. 
            They are detailed in the following sections.</p>
            <section><title>Unexpected messages</title>
                <ul>
                    <li>When a SIP message that <strong>can</strong> be
                    correlated to an existing call (with the
                    <code>Call-ID:</code> header) but is not expected in the
                    scenario is received, SIPp will send a CANCEL message if no
                    200 OK message has been received or a BYE message if a 200
                    OK message has been received. The call will be marked 
                    as failed. If the unexpected message is a 4XX or 5XX,
                    SIPp will send an ACK to this message, close the call
                    and mark the call as failed.</li>
                    <li>When a SIP message that <strong>can't</strong> be
                    correlated to an existing call (with the
                    <code>Call-ID:</code> header) is received, SIPp will send a
                    BYE message. The call will not be counted at all.</li>
                    <li>When a SIP "PING" message is received, SIPp will send
                    an ACK message in response. This message is not counted as 
                    being an unexpected message. But it is counted in the "AutoAnswered"
                    <link href="#stats">statistic counter</link>.
                    </li>
                    <li>An unexpected message that is not a SIP message will
                    be simply dropped.</li>
                </ul>
            </section>
            <section><title>Retransmissions (UDP only)</title>
                <p>A retransmission mechanism exists in UDP transport mode. 
                To activate the retransmission mechanism, the "send" command must include
                the "retrans" attribute.</p>
                <p>When it is activated and a SIP message is sent and no ACK or
                response is received in answer to this message, the message is
                re-sent.</p>
                <p><code>&lt;send retrans="500"&gt;</code>: will retransmit the
                message every 500 milliseconds.</p>
                <p>Even if retrans is specified in your scenarios, you can override this by 
                using the <code>-nr</code> command line option to globally disable the
                retransmission mechanism.</p>
            </section>
            <section><title>Log files (error + log + screen)</title>
                <p>There are several ways to trace what is going on during your SIPp runs.</p>
                <ul>
                    <li>You can log sent and received SIP messages in &lt;pid&gt;_&lt;name_of_the_scenario&gt;_messages.log by
                    using the command line parameter <code>-trace_msg</code>. The messages are time-stamped so that you
                    can track them back.</li>
                    <li>You can trace all unexpected messages or events in &lt;pid&gt;_&lt;name_of_the_scenario&gt;_errors.log by using
                    the command line parameter <code>-trace_err</code>.</li>
                    <li>You can save in a file the statistics screens, as displayed in
                    the interface. This is especially useful when running SIPp in background
                    mode.<br/>
                    This can be done in two ways:
                    <ul>
                      <li>When SIPp exits to get a final status report (-trace_screen option)</li>
                      <li>On demand by using USR2 signal (example: <code>kill -SIGUSR2 738</code>)</li>
                    </ul>
                    </li>
                    <li>You can log all call ids for calls that timeout (the maximum
                    number of retransmissions for UDP transport is reached)
                    by using the command line parameter <code>-trace_timeout</code></li>
                </ul>
            </section>
        </section>
        <section><title>Online help (-h)</title>
          <p>The online help, available through the -h option is duplicated here for your
          convenience</p>
          <source>
Usage:

  sipp remote_host[:remote_port] [options]

  Available options:

   -v               : Display version and copyright information.

   -bg              : Launch the tool in background mode.

   -p local_port    : Set the local port number. Default is a
                      random free port chosen by the system.

   -i local_ip      : Set the local IP address for 'Contact:',
                      'Via:', and 'From:' headers. Default is
                      primary host IP address.

   -inf file_name   : Inject values from an external CSV file during calls
                      into the scenarios.
                      First line of this file say whether the data is
                      to be read in sequence (SEQUENTIAL) or random
                      (RANDOM) order.
                      Each line corresponds to one call and has one or
                      more ';' delimited data fields. Those fields can be
                      referred as [field0], [field1], ... in the xml
                      scenario file.

   -d duration      : Controls the length (in milliseconds) of
                      calls. More precisely, this controls
                      the duration of 'pause' instructions in
                      the scenario, if they do not have a
                      'milliseconds' section. Default value is 0.

   -r rate (cps)    : Set the call rate (in calls per seconds).
                      This value can be changed during test by
                      pressing '+','_','*' or '/'. Default is 10.
                      pressing '+' key to increase call rate by 1,
                      pressing '-' key to decrease call rate by 1,
                      pressing '*' key to increase call rate by 10,
                      pressing '/' key to decrease call rate by 10.
                      If the -rp option is used, the call rate is
                      calculated with the period in ms given
                      by the user.

   -rp period (ms)  : Specify the rate period in milliseconds for the call
                      rate.
                      Default is 1 second.
                      This allows you to have n calls every m milliseconds
                      (by using -r n -rp m).
                      Example: -r 7 -rp 2000 ==&gt; 7 calls every 2 seconds.

   -sf filename     : Loads an alternate xml scenario file.
                      To learn more about XML scenario syntax,
                      use the -sd option to dump embedded
                      scenarios. They contain all the necessary
                      help.

   -sn name         : Use a default scenario (embedded in
                      the sipp executable). If this option is omitted,
                      the Standard SipStone UAC scenario is loaded.
                      Available values in this version:

                        'uac'      : Standard SipStone UAC (default).
                        'uas'      : Simple UAS responder (UDP only).
                        'regexp'   : Standard SipStone UAC - with
                                     regexp and variables.

                      Default 3pcc scanerios (see -3pcc option):

                        '3pcc-C-A' : Controller A side (must be started
                                     after all other 3pcc scenarios)
                        '3pcc-C-B' : Controller B side.
                        '3pcc-A'   : A side.
                        '3pcc-B'   : B side.

   -sd name         : Dumps a default scenario (embeded in
                      the sipp executable)

   -t [u1|un|t1|tn] : Set the transport mode:

                        u1: UDP with one socket (default),
                        un: UDP with one socket per call,
                        t1: TCP with one socket,
                        tn: TCP with one socket per call.

   -trace_msg       : Displays sent and received SIP messages in
                      &lt;ppid&gt;_&lt;scenario file name&gt;_messages.log

   -trace_screen    : Dump statistic screens in the
                      &lt;ppid&gt;_&lt;scenario_name&gt;_screens.log file when
                      quitting SIPp. Useful to get a final status report
                      in background mode (-bg option).

   -trace_timeout   : Displays call ids for calls with timeouts in
                      &lt;ppid&gt;_&lt;scenario file name&gt;_timeout.log

   -trace_stat      : Dumps all statistics in &lt;ppid&gt;_&lt;scenario_name&gt;.csv&gt;
                      file. Use the '-h stat' option for a detailed
                      description of the statistics file content.

   -stf file_name   : Set the file name to use to dump statistics

   -trace_err       : Trace all unexpected messages in
                      &lt;ppid&gt;_&lt;scenario file name&gt;_errors.log.

   -s service_name  : Set the username part of the resquest URI.
                      Default is 'service'.

   -f frequency     : Set the statistics report frequency on screen
                      (in seconds). Default is 1.

   -fd frequency    : Set the statistics dump log report frequency
                      (in seconds). Default is 60.

   -l calls_limit   : Set the maximum number of simultaneous
                      calls. Once this limit is reached, traffic
                      is decreased until the number of open calls
                      goes down. Default:

                        (3 * call_duration (s) * rate).

   -m calls         : Stop the test and exit when 'calls' calls are
                      processed.

   -mp local_port   : Set the local RTP echo port number. Default
                      is none. RTP/UDP packets received on that
                      port are echoed to their sender.

   -mi local_rtp_ip : Set the local IP address for RTP echo.

   -3pcc ip:port    : Launch the tool in 3pcc mode ("Third Party
                      call control"). The passed ip address
                      is depending on the 3PCC role.
                      - When the first twin command is 'sendCmd' then
                      this is the address of the remote twin socket.
                      Example: 3PCC-C-A scenario.
                      - When the first twin command is 'recvCmd' then
                      this is the address of the local twin socket.
                      Example: 3PCC-C-B scenario.

   -nr              : Disable retransmission in UDP mode.
   
   -rsa host:port   : Set the remote sending address to host:port.
                      for sending the messages.

Signal handling:

   SIPp can be controlled using posix signals. The following signals
   are handled:
   USR1: Similar to press 'q' keyboard key. It triggers a soft exit
         of SIPp. No more new calls are placed and all ongoing calls
         are finished before SIPp exits.
         Example: kill -SIGUSR1 732
   USR2: Triggers a dump of all statistics screens in
         &lt;ppid&gt;_&lt;scenario_name&gt;_screens.log file. Especially useful
         in background mode to know what the current status is.
         Example: kill -SIGUSR2 732

Exit code:

   Upon exit (on fatal error or when the number of asked calls (-m
   option) is reached, sipp exits with one of the following exit
   code:
    0: All calls were successful
    1: At least one call failed
   99: Normal exit without calls processed
   -1: Fatal error


Example:

   Run sipp with embedded server (uas) scenario:
     ./sipp -sn uas
   On the same host, run sipp with embedded client (uac) scenario
     ./sipp -sn uac 127.0.0.1

          </source>
        </section>
    </section>
    <section><title>Useful tools aside SIPp</title>
        <section><title>JEdit</title>
            <p>JEdit (<fork href="http://www.jedit.org/">http://www.jedit.org/</fork>) is a
            GNU GPL text editor written in Java, and available in almost all
            platforms. It's extremely powerful and can be used
            to edit SIPp scenarios with syntax checking if you put the DTD 
            (<fork href="http://sipp.sourceforge.net/doc/sipp.dtd">sipp.dtd</fork>)
            in the same directory as your XML scenario.</p>
        </section>
        <section><title>Ethereal/tethereal</title>
            <p>Ethereal (<fork href="http://www.ethereal.com/">http://www.ethereal.com/</fork>) is a
            GNU GPL protocol analyzer. It supports SIP.</p>
            <p></p>
        </section>
        <section><title>SIP callflow</title>
            <p>When tracing SIP calls, it is very useful to be able 
            to get a call flow from an ethereal trace. The "callflow" tool allows you to do 
            that in a graphical way:
            <fork href="http://callflow.sourceforge.net/">http://callflow.sourceforge.net/</fork></p>
            <p>An equivalent exist if you want to generate HTML only call flows
            <fork href="http://www.iptel.org/~sipsc/">http://www.iptel.org/~sipsc/</fork></p>
        </section>
    </section>
    <section><title>Getting support</title>
        <p>You can likely get email-based support from the sipp users community. The mailing list address is 
        <link href="mailto:sipp-users@lists.sourceforge.net">sipp-users@lists.sourceforge.net</link>.
        To protect you from SPAM, this list is restricted (only people that actually subscribed can
        post). Also, you can browse the SIPp mailing list archive: 
        <link href="http://lists.sourceforge.net/lists/listinfo/sipp-users">http://lists.sourceforge.net/lists/listinfo/sipp-users</link></p>
    </section>
    <section><title>Contributing to SIPp</title>
        <p>Of course, we welcome contributions! If you created a feature 
        for SIPp, please send the "diff" output 
        (<code>diff -bruN old_sipp_directory new_sipp_directory</code>)
        so that it can be integrated in SIPp.</p>
    </section>
  </body>
</document>
