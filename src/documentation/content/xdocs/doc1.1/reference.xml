<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document> 
  <header> 
    <title>SIPp</title>
    <subtitle>Reference documentation v1.1</subtitle>
    <authors>
        <person name="Richard GAYRAUD [initial code]" email="richard_gayraud@users.sourceforge.net"/>
        <person name="Olivier JACQUES [code/documentation]" email="ojacques@users.sourceforge.net"/>
        <person name="Many contributors [code]" email="none@email.com"/>
    </authors>
  </header> 
  <body> 
    <section>
      <title>Foreword</title>
      <warning>This documentation is for 'unstable' version 1.1. It does not apply
      to version 1.0 and below.</warning>
      <p>SIPp is a performance testing tool for the SIP protocol. It includes a
      few basic SipStone user agent scenarios (UAC and UAS) and establishes and
      releases multiple calls with the INVITE and BYE methods. It can also reads
      XML scenario files describing any performance testing configuration. It
      features the dynamic display of statistics about running tests (call rate,
      round trip delay, and message statistics), periodic CSV statistics dumps,
      TCP and UDP over multiple sockets or multiplexed with retransmission
      management, regular expressions and variables in scenario files, and
      dynamically adjustable call rates.</p>
      <p>SIPp can be used to test many real SIP equipements like SIP proxies,
      B2BUAs, SIP media servers, SIP/x gateways, SIP PBX, ... It is also very
      useful to emulate thousands of user agents calling your SIP system. </p>
      <p><strong>Want to see it?</strong></p>
      <p>Here is a screenshot</p>
      <p><img src="images/sipp-01.jpg" alt="SIPp screenshot" /></p>
      <p>And here is a video (Windows Media Player 9 codec or above required) of
      SIPp in action:</p>
      <p><icon src="images/wmv.gif" alt="wmv" /><a href="images/sipp-01.wmv">sipp-01.wmv</a></p>
    </section>
    <section><title>Installation</title>
        <section>
          <title>Getting SIPp</title>
           <p>SIPp is released under the
           <a href="http://www.gnu.org/copyleft/gpl.html">GNU GPL license</a>.
           All the terms of the license apply. It is provided to the SIP
           community by <a href="http://www.hp.com">Hewlett-Packard</a>
           engineers in hope it can be useful.</p> <p>We receive some support
           from our company to work on this tool freely, but <strong>HP does not
           provide any support nor warranty concerning SIPp.</strong></p>
            </section>
        <section><title>Stable release</title>
            <p>Like many other "open source" projects, there are two versions of
            SIPp: a stable and unstable release. Stable release: before being
            labelled as "stable", a SIPp release is thoroughly tested. So you
            can be confident that all mentioned features will work :) </p>
            <note>Use the stable release for your everyday use and if you are
            not blocked by a specific feature present in the "unstable release"
            (see below).</note> <p><a
            href="http://sourceforge.net/project/showfiles.php?group_id=104305">SIPp
            stable download page</a></p>
            </section>
        <section><title>Unstable release</title>
            <p>Unstable release: all new features and bug fixes are checked in
            <a href="http://sipp.svn.sourceforge.net/viewvc/sipp/sipp/trunk/">SIPp's
            SVN</a> repository as soon as they are available. Every night, an
            automatic extraction is done and the source code of this release is
            made available. </p>
            <note> Use the unstable release if you absolutely need a bug fix or
            a feature that is not in the stable release. </note>
            <p><a href="http://sipp.sourceforge.net/snapshots/">SIPp "unstable" download page</a></p>
        </section>
        <section><title>Available platforms</title>
            <p>SIPp is available on almost all UNIX platforms: HPUX, Tru64,
            Linux (RedHat, Debian, FreeBSD), Solaris/SunOS.</p>
            <p>A Windows port has been contributed. You can now compile SIPp under
            Cygwin. A binary package with a Windows installer is also available. 
            Check <a href="http://sourceforge.net/project/showfiles.php?group_id=104305">the
            download page</a> to download it and run SIPp under Windows.</p>
            <note>Since 1.1, SIPp works only over Windows XP. SIPp will not
            work on Win2000. This is because of IPv6 support.</note>
            </section> 
        <anchor id="installing" /><section><title>Installing SIPp</title>
          <ul>
          <li>On Linux, SIPp is provided in the form of source code. You will need to
            compile SIPp to actually use it.</li>
          <li>Pre-requisites to compile SIPp are (see <a href="http://sipp.sourceforge.net/wiki/index.php/Compilation" >Compilation tips</a>):
            <ul>
              <li>C++ Compiler</li>
              <li>curses or ncurses library</li>
              <li>For authentication and TLS support: OpenSSL >= 0.9.8</li>
              <li>For pcap play support: libpcap and libnet</li>
            </ul>
          </li>
          <li>You have four options to compile SIPp:
            <ul>
              <li><strong>Without TLS (Transport Layer Security) and authentication support</strong>:
              This is the recommended setup if you don't need to handle SIP authentication
            and/or TLS. In this case, there are <strong>no depencies to install</strong> before
            building SIPp. It is straight forward:
<source># gunzip sipp-xxx.tar.gz
# tar -xvf sipp-xxx.tar
# cd sipp
# make
</source></li>
              <li><strong>With TLS and <a href="#authentication">authentication</a> support</strong>, you must have
              installed <a href="http://www.openssl.org/">OpenSSL library</a> (>=0.9.8) 
              (which may come with your system). Building SIPp consist only in adding
              the "ossl" option to the make command:
<source># gunzip sipp-xxx.tar.gz
# tar -xvf sipp-xxx.tar
# cd sipp
# make ossl
</source></li>
              <li><strong>With <a href="#pcapplay">PCAP play</a> and without <a href="#authentication">authentication</a> support</strong>:
<source># gunzip sipp-xxx.tar.gz
# tar -xvf sipp-xxx.tar
# cd sipp
# make pcapplay
</source></li>
              <li><strong>With <a href="#pcapplay">PCAP play</a> and <a href="#authentication">authentication</a> support</strong>:
<source># gunzip sipp-xxx.tar.gz
# tar -xvf sipp-xxx.tar
# cd sipp
# make pcapplay_ossl
</source></li>

            </ul>
          </li>
          <li>On Windows, SIPp is provided both with the source and the pre-compiled 
          executable. Just execute the installer to have SIPp installed.
          <warning>SIPp 1.1 compiles under CYGWIN, provided that you installed IPv6
          extension for CYGWIN (<a href="http://win6.jp/Cygwin/">http://win6.jp/Cygwin/</a>),
          as well as OpenSSL and libncurses.</warning></li>
          </ul>
        </section>     
        <anchor id="filedesc" /><section><title>Increasing File Descriptors Limit</title>
        <p>If your system does not supports enough file descriptors, 
        you may experience problems when using the TCP/TLS mode with many simultaneous calls.</p>
        <p>You have two ways to overcome this limit: either use the <a href="#maxsocket"><code>-max_socket</code></a>
        command line option or change the limits of your system.</p> 
        <p>Depending on the operating system you use, different procedures 
        allow you to increase the maximum number of file descriptors:</p>
        <ul>
            <li><p>On Linux 2.4 kernels the default number of file descriptors can 
            be increased by modifying the <code>/etc/security/limits.conf</code> 
            and the <code>/etc/pam.d/login</code> file. </p>
            <p>Open the <code>/etc/security/limits.conf</code> file and add the following lines:</p>
<source>soft nofile 1024
hard nofile 65535</source>
            <p>Open the <code>/etc/pam.d/login</code> and add the following line</p>
<source>session required /lib/security/pam_limits.so</source>
            <p>The system file descriptor limit is set in the <code>/proc/sys/fs/file-max</code> file. 
            The following command will increase the file descriptor limit:</p>
<source>echo 65535> /proc/sys/fs/file-max</source>
            <p>To increase the number of file descriptors to its maximum limit 
            (65535) set in the <code>/etc/security/limits.conf</code> file, type:</p>
<source>ulimit -n unlimited</source>
            <p>Logout then login again to make the changes effective.</p>
            </li>
            <li><p>On HP-UX systems the default number of file descriptors 
            can be increased by modifying the system configuration with the sam utility. 
            In the Kernel Configuration menu, select Configurable parameters, 
            and change the following attributes:</p> 
<source>maxfiles : 4096
maxfiles_lim : 4096
nfiles : 4096
ninode : 4096
max_thread_proc : 4096
nkthread : 4096</source>
            </li>
          </ul>
        </section>
    </section>
   <section><title>Using SIPp</title>
        <section>
          <title>Main features</title>
            <p>SIPp allows to generate one or many SIP calls to one remote
            system. The tool is started from the command line. In this example,
            two SIPp are started in front of each other to demonstrate SIPp
            capabilities.</p>
            <p>Run sipp with embedded server (uas) scenario:</p>
            <source># ./sipp -sn uas</source>
            <p>On the same host, run sipp with embedded client (uac) scenario</p>
            <source># ./sipp -sn uac 127.0.0.1</source>
        </section>     
        <section>
          <title>Integrated scenarios</title>
            <p>Integrated scenarios? Yes, there are scenarios that are embedded
            in SIPp executable. While you can create your own custom SIP
            scenarios (see <a href="#xmlsyntax">how to create your own XML
            scenarios</a>), a few basic (yet useful) scenarios are available
            in SIPp executable.</p>
            <section>
              <title>UAC</title>
                <p>Scenario file: <a href="uac.xml.html">uac.xml</a> (<a href="uac.xml">original XML file</a>)</p>
                <source>SIPp UAC            Remote
    |(1) INVITE         |
    |------------------&gt;|
    |(2) 100 (optional) |
    |&lt;------------------|
    |(3) 180 (optional) |
    |&lt;------------------|
    |(4) 200            |
    |&lt;------------------|
    |(5) ACK            |
    |------------------&gt;|
    |                   |
    |(6) PAUSE          |
    |                   |
    |(7) BYE            |
    |------------------&gt;|
    |(8) 200            |
    |&lt;------------------|
</source>
            </section>
            <anchor id="uac_with_media"/><section>
              <title>UAC with media</title>
                <p>Scenario file: <a href="uac_pcap.xml.html">uac_pcap.xml</a> (<a href="uac_pcap.xml">original XML file</a>)</p>
                <source>SIPp UAC            Remote
    |(1) INVITE         |
    |------------------&gt;|
    |(2) 100 (optional) |
    |&lt;------------------|
    |(3) 180 (optional) |
    |&lt;------------------|
    |(4) 200            |
    |&lt;------------------|
    |(5) ACK            |
    |------------------&gt;|
    |                   |
    |(6) RTP send (8s)  |
    |==================&gt;|
    |                   |
    |(7) RFC2833 DIGIT 1|
    |==================&gt;|
    |                   |
    |(8) BYE            |
    |------------------&gt;|
    |(9) 200            |
    |&lt;------------------|
</source>
            </section>
            <section>
              <title>UAS</title>
                <p>Scenario file: <a href="uas.xml.html">uas.xml</a> (<a href="uas.xml">original XML file</a>)</p>
                <source>Remote              SIPp UAS
    |(1) INVITE         |
    |------------------&gt;|
    |(2) 180            |
    |&lt;------------------|
    |(3) 200            |
    |&lt;------------------|
    |(4) ACK            |
    |------------------&gt;|
    |                   |
    |(5) PAUSE          |
    |                   |
    |(6) BYE            |
    |------------------&gt;|
    |(7) 200            |
    |&lt;------------------|
</source>
            </section>
            <section>
              <title>regexp</title>
                <p>Scenario file: <a href="regexp.xml.html">regexp.xml</a> (<a href="regexp.xml">original XML file</a>)</p>
                <p>This scenario, which behaves as an UAC is explained in greater details in <a href="#action_regexp">this section</a>.</p>
                <source>SIPp regexp         Remote
    |(1) INVITE         |
    |------------------&gt;|
    |(2) 100 (optional) |
    |&lt;------------------|
    |(3) 180 (optional) |
    |&lt;------------------|
    |(4) 200            |
    |&lt;------------------|
    |(5) ACK            |
    |------------------&gt;|
    |                   |
    |(6) PAUSE          |
    |                   |
    |(7) BYE            |
    |------------------&gt;|
    |(8) 200            |
    |&lt;------------------|
</source>
            </section>
            <anchor id="scenario_branch" /><section>
              <title>branch</title>
                <p>Scenario files: <a href="branchc.xml.html">branchc.xml</a> (<a href="branchc.xml">original XML file</a>) and
                <a href="branchs.xml.html">branchs.xml</a> (<a href="branchs.xml">original XML file</a>)</p>
                <p>Those scenarios, which work against each other (branchc for client side and 
                branchs for server side) are explained in greater details in <a href="#branching">this section</a>.</p>
                <source><![CDATA[    REGISTER ---------->
         200 <----------
         200 <----------
      INVITE ---------->
         100 <----------
         180 <----------
         403 <----------
         200 <----------
         ACK ---------->
             [  5000 ms]
         BYE ---------->
         200 <----------]]></source>
            </section>
            <anchor id="ThreePCC" /><section>
              <title>3PCC</title>
                <p>3PCC stands for 3rd Party Call Control. 3PCC is described in 
                <a href="http://www.ietf.org/rfc/rfc3725.txt">RFC 3725</a>.
                While this feature was first developped to allow 3PCC like scenarios, 
                it can also be used for every case where you would need one SIPp to talk
                to several remotes.</p>
                <p>In order to keep SIPp simple (remember, it's a test tool!),
                one SIPp instance can only talk to one remote. Which is an issue
                in 3PCC call flows, like call flow I (SIPp beeing a controller):</p>
                <source>             A              Controller               B
             |(1) INVITE no SDP  |                   |
             |&lt;------------------|                   |
             |(2) 200 offer1     |                   |
             |------------------&gt;|                   |
             |                   |(3) INVITE offer1  |
             |                   |------------------&gt;|
             |                   |(4) 200 OK answer1 |
             |                   |&lt;------------------|
             |                   |(5) ACK            |
             |                   |------------------&gt;|
             |(6) ACK answer1    |                   |
             |&lt;------------------|                   |
             |(7) RTP            |                   |
             |.......................................|
</source>
                <p>Scenario file: <a href="3pcc-A.xml.html">3pcc-A.xml</a> (<a href="3pcc-A.xml">original XML file</a>)</p>
                <p>Scenario file: <a href="3pcc-B.xml.html">3pcc-B.xml</a> (<a href="3pcc-B.xml">original XML file</a>)</p>
                <p>Scenario file: <a href="3pcc-C-A.xml.html">3pcc-C-A.xml</a> (<a href="3pcc-C-A.xml">original XML file</a>)</p>
                <p>Scenario file: <a href="3pcc-C-B.xml.html">3pcc-C-B.xml</a> (<a href="3pcc-C-B.xml">original XML file</a>)</p>
                <p>The 3PCC feature in SIPp allows to have two SIPp instances
                launched and synchronised together. If we take the example of 
                call flow I, one SIPp instance will take care of the dialog with
                remote A (this instance is called 3PCC-C-A for 3PCC-Controller-A-Side) 
                and another SIPp instance will take care of the dialog with remote B 
                (this instance is called 3PCC-C-B for 3PCC-Controller-B-Side).</p>
                <p>The 3PCC call flow I will, in reality, look like this
                (Controller has been divided in two SIPp instances):</p>
                <source>
             A             Controller A         Controller B            B
             |(1) INVITE no SDP  |                  |                   |
             |&lt;------------------|                  |                   |
             |(2) 200 offer1     |                  |                   |
             |------------------>|                  |                   |
             |                sendCmd  (offer1)     |                   |
             |                   |-----------------&gt;|                   |
             |                   |               recvCmd                |
             |                   |                  |(3) INVITE offer1  |
             |                   |                  |------------------&gt;|
             |                   |                  |(4) 200 OK answer1 |
             |                   |                  |&lt;------------------|
             |                   |               sendCmd                |
             |                   |     (answer1)    |                   |
             |                   |&lt;-----------------|                   |
             |                 recvCmd              |(5) ACK            |
             |                   |                  |------------------&gt;|
             |(6) ACK answer1    |                  |                   |
             |&lt;------------------|                  |                   |
             |(7) RTP            |                  |                   |
             |..........................................................|
</source>
                <p>As you can see, we need to pass informations
                between both sides of the controller. SDP "offer1" is provided
                by A in message (2) and needs to be sent to B side in message (3). 
                This mechanism is implemented 
                in the scenarios through the &lt;<a href="#sendCmd">sendCmd</a>&gt; command. This:</p>
<source>&lt;sendCmd&gt;
  &lt;![CDATA[
    Call-ID: [call_id]
    [$1]

   ]]&gt;
&lt;/sendCmd&gt;
</source>
                <p>Will send a "command" to the twin SIPp instance. Note that including
                the Call-ID is mandatory in order to correlate the commands to
                actual calls. In the same manner, this:</p>
<source>&lt;recvCmd&gt;
  &lt;action
     &lt;ereg regexp="Content-Type:.*"
           search_in="msg"
           assign_to="2"/&gt;
  &lt;/action&gt;
&lt;/recvCmd&gt;
</source>
                <p>Will receive a "command" from the twin SIPp instance. 
                Using the <a href="#action_regexp">regular expression</a> mechanism, 
                the content is retrieved
                and stored in a call variable ($2 in this case), ready to be
                reinjected</p>
<source>  &lt;send&gt;
    &lt;![CDATA[

      ACK sip:[service]@[remote_ip]:[remote_port] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port]
      From: sipp &lt;sip:sipp@[local_ip]:[local_port]&gt;;tag=[call_number]
      To: sut &lt;sip:[service]@[remote_ip]:[remote_port]&gt;[peer_tag_param]
      Call-ID: [call_id]
      CSeq: 1 ACK
      Contact: sip:sipp@[local_ip]:[local_port]
      Max-Forwards: 70
      Subject: Performance Test
      [$2]

    ]]&gt;
  &lt;/send&gt;
</source>                
                <p>In other words, <a href="#sendCmd">sendCmd</a> and <a href="#recvCmd">recvCmd</a> can be seen as synchronization points
                between two SIPp instances, with the ability to pass parameters
                between each other.</p>
                <p>Another scenario that has been reported to be do-able with the
                3PCC feature is the following:</p>
                <ul>
                  <li>A calls B. B answers. B and A converse</li>
                  <li>B calls C. C answers. C and B converse</li>
                  <li>B "REFER"s A to C and asks to replace A-B call with B-C call.</li>
                  <li>A accepts. A and C talk. B drops out of the calls.</li>
                </ul>
            </section>
        </section>
        <anchor id="traffic_control" /><section><title>Traffic control</title>
        <p>SIPp generates SIP traffic according to the scenario specified. You
        can control the number of calls (scenario) that are started per second.
        This can be done either: </p>        
        <ul>
            <li>Interactively, by pressing keys on the keyboard
              <ul>
                  <li>'+' key to increase call rate by 1</li>
                  <li>'-' key to decrease call rate by 1</li>
                  <li>'*' key to increase call rate by 10</li>
                  <li>'/' key to decrease call rate by 10</li>
              </ul>
            </li>
            <li>At starting time, by specifying parameters on the command line:
                <ul>
                    <li>"-r" to specify the call rate in number of calls per seconds</li>
                    <li>"-rp" to specify the "<strong>r</strong>ate <strong>p</strong>eriod" 
                    in milliseconds for the call rate (default is 1000ms/1sec). 
                    This allows you to have n calls every m milliseconds (by using <code>-r n -rp m</code>).
                        <note>Example: run SIPp at 7 calls every 2 seconds (3.5 calls per second)</note>
                        <source>./sipp -sn uac -r 7 -rp 2000 127.0.0.1</source>
                    </li>
                </ul>
            </li>
        </ul>
        <p>You can also <strong>pause</strong> the traffic by pressing the 'p' key. 
        SIPp will stop placing new calls and wait until all current calls go to their end. 
        You can <strong>resume</strong> the traffic by pressing 'p' again.</p>
        <p>To <strong>quit</strong> SIPp, press the 'q' key. 
        SIPp will stop placing new calls and wait until all current calls go to their end.
        SIPp will then exit.</p>
        <note><strong>TIP:</strong> you can place a defined number of calls and
        have SIPp exit when this is done. Use the <code>-m</code> option on the
        command line.</note>
        </section>
        <anchor id="remote_control" /><section><title>Remote control</title>
          <p>SIPp can be "remote-controlled" through a UDP socket. This allows for example</p>
          <ul>
            <li>To automate a series of actions, like increasing the call rate smoothly, 
            wait for 10 seconds, increase more, wait for 1 minute and loop</li>
            <li>Have a feedback loop so that an application under test can
            remote control SIPp to lower the load, pause the traffic, ...</li>
          </ul>
          <p>Each SIPp instance is listening to a UDP socket. It 
          starts to listen to port 8888 and each following SIPp instance (up to 10)
          will listen to base_port + 1 (8889, 8890, ...).</p>
          <p>It is then possible to control SIPp like this:</p>
          <source>echo p >/dev/udp/x.y.z.t/8888 -> put SIPp in pause state (p key)
echo q >/dev/udp/x.y.z.t/8888 -> quit SIPp (q key)</source>
          <note>All keys available through keyboard are also available in 
          the remote control interface</note>
          <p>You could also have a small shell script to automate a serie of action. 
          For example, this script will 
          increase the call rate by 10 more new calls/s every 5 seconds, wait at this call rate
          for one minute and exit SIPp:</p>
          <source>#!/bin/sh
echo "*" >/dev/udp/127.0.0.1/8889
sleep 5
echo "*" >/dev/udp/127.0.0.1/8889
sleep 5
echo "*" >/dev/udp/127.0.0.1/8889
sleep 5
echo "*" >/dev/udp/127.0.0.1/8889
sleep 60
echo "q" >/dev/udp/127.0.0.1/8889
</source>
        </section>
        <section><title>Running SIPp in background</title>
          <p>SIPp can be launched in background mode (<code>-bg</code> command
          line option).</p>
          <p>By doing so, SIPp will be detached from the current terminal and run
          in the background. The PID of the SIPp process is provided. If you didn't specify a number of calls to execute
          with the <code>-m</code> option, SIPp will run forever.</p>
          <p>There is a mechanism implemented to stop SIPp smoothly. The command
          <code>kill -SIGUSR1 [SIPp_PID]</code> will instruct SIPp to stop placing
          any new calls and finish all ongoing calls before exiting.</p>
        </section>
        <anchor id="xmlsyntax" /><section><title>Create your own XML scenarios</title>
            <p>Of course embedded scenarios will not be enough. So it's time to
            create your own scenarios. A SIPp scenario is written in XML
            (a DTD that may help you write SIPp
            scenarios does exist and has been tested with jEdit - this is described in a later section).
            A scenario will always start with:</p>
            <source>&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;
&lt;scenario name="Basic Sipstone UAC"&gt;
</source>
            <p>And end with:</p>
<source>&lt;/scenario&gt;</source>
            <p>Easy, huh? Ok, now let's see what can be put inside. You are not
            obliged to read the whole table now! Just go in the next section for
            an example.</p>
            <table>
                <caption>List of commands with their attributes</caption>
                <tr>
                    <th>Command</th>
                    <th>Attribute(s)</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td><anchor id="send"/><strong>&lt;send&gt;</strong></td>
                    <td>retrans</td>
                    <td>Used for UDP transport only: it specifies the T1 timer value,
                    as described in SIP RFC 3261, section 17.1.1.2.</td>
                    <td><code>&lt;send retrans="500"&gt;</code>: will initiate T1 timer to 500 milliseconds (RFC3261 default).</td>
                </tr>            
                <tr>
                    <td><anchor id="start_rtd"/></td>
                    <td>start_rtd</td>
                    <td>Specifies the message on which SIPp starts the "<strong>R</strong>esponse <strong>T</strong>ime <strong>D</strong>uration" timer.
                    It is used to compute time between message exchanges. 
                    By default, start_rtd is set on the first message of the scenario.</td>
                    <td><code>&lt;send start_rtd="true"&gt;</code>: the timer will start when the enclosed message is sent.</td>
                </tr>            
                <tr>
                    <td><anchor id="rtd"/></td>
                    <td>rtd</td>
                    <td>Specifies the message on which SIPp stops the "<strong>R</strong>esponse <strong>T</strong>ime <strong>D</strong>uration" timer.
                    By default, rtd is set on the last message of the scenario.</td>
                    <td><code>&lt;send rtd="true"&gt;</code>: the timer will stop when the enclosed message is sent.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>crlf</td>
                    <td>Displays an empty line <strong>after</strong> the arrow for the message in main SIPp screen.</td>
                    <td><code>&lt;send crlf="true"&gt;</code></td>
                </tr>            
                <tr>
                    <td></td>
                    <td>lost</td>
                    <td>Emulate packet lost. The value is specified as a percentage.</td>
                    <td><code>&lt;send lost="10"&gt;</code>: 10% of the message sent are actually not sent :).</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>next</td>
                    <td>You can put a "next" in a send to go to another part of the script when you are done with sending the message. 
                    See <a href="#branching">conditional branching</a> section for more info.</td>
                    <td>Example to jump to label "12" after sending an ACK:<source><![CDATA[  <send next="12">
    <![CDATA[

      ACK sip:[service]@[remote_ip]:[remote_port] SIP/2.0
      Via: ...
      From: ...
      To: ...
      Call-ID: ...
      Cseq: ...
      Contact: ...
      Max-Forwards: ...
      Subject: ...
      Content-Length: 0

    ]]>]]&gt;
  &lt;/send&gt;
</source></td>
                </tr>
                <tr>
                    <td></td>
                    <td>test</td>
                    <td>You can put a "test" next to a "next" attribute to indicate
                    that you only want to branch to the label specified with "next"
                    if the variable specified in "test" is set (through <a href="#action_regexp">regexp</a>
                    for example).
                    See <a href="#branching">conditional branching</a> section for more info.</td>
                    <td>Example to jump to label "6" after sending an ACK only if
                    variable 4 is set:<source><![CDATA[  <send next="6" test="4">
    <![CDATA[

      ACK sip:[service]@[remote_ip]:[remote_port] SIP/2.0
      Via: ...
      From: ...
      To: ...
      Call-ID: ...
      Cseq: ...
      Contact: ...
      Max-Forwards: ...
      Subject: ...
      Content-Length: 0

    ]]>]]&gt;
  &lt;/send&gt;
</source></td>
                </tr>
                <tr>
                    <td><anchor id="recv"/><strong>&lt;recv&gt;</strong></td>
                    <td>response</td>
                    <td>Indicates what SIP message code is expected.</td>
                    <td><code>&lt;recv response="200"&gt;</code>: SIPp will expect a SIP message with code "200".</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>request</td>
                    <td>Indicates what SIP message request is expected.</td>
                    <td><code>&lt;recv request="ACK"&gt;</code>: SIPp will expect an "ACK" SIP message.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>optional</td>
                    <td>Indicates if the message to receive is optional. In case of an optional
                    message and if the message is actually received, it is not seen as a unexpected message.</td>
                    <td><code>&lt;recv response="100" optional="true"&gt;</code>: The 100 SIP message can be received without 
                    being considered as "unexpected".</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>crlf</td>
                    <td>Displays an empty line <strong>after</strong> the arrow for the message in main SIPp screen.</td>
                    <td><code>&lt;recv crlf="true"&gt;</code></td>
                </tr>            
                <tr>
                    <td></td>
                    <td>rrs</td>
                    <td><strong>R</strong>ecord <strong>R</strong>oute <strong>S</strong>et. if this attribute is set to "true",
                    then the "Record-Route:" header of the message received is stored and can be recalled using the <strong>[routes]</strong> keyword.</td>
                    <td><code>&lt;recv response="100" rrs="true"&gt;</code>.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>auth</td>
                    <td><a href="#authentication">Authentication</a>. if this attribute is set to "true",
                    then the "Proxy-Authenticate:" header of the message received is stored and is used to build
                    the <strong>[authentication]</strong> keyword.</td>
                    <td><code>&lt;recv response="407" auth="true"&gt;</code>.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>start_rtd</td>
                    <td>Specifies the message on which SIPp starts the "<strong>R</strong>esponse <strong>T</strong>ime <strong>D</strong>uration" timer.
                    It is used to compute time between message exchanges. 
                    By default, start_rtd is set on the first message of the scenario.</td>
                    <td><code>&lt;recv start_rtd="true"&gt;</code>: the timer will start when the enclosed message is sent.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>rtd</td>
                    <td>Specifies the message on which SIPp stops the "<strong>R</strong>esponse <strong>T</strong>ime <strong>D</strong>uration" timer.
                    By default, rtd is set on the last message of the scenario.</td>
                    <td><code>&lt;recv rtd="true"&gt;</code>: the timer will stop when the enclosed message is sent.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>lost</td>
                    <td>Emulate packet lost. The value is specified as a percentage.</td>
                    <td><code>&lt;recv lost="10"&gt;</code>: 10% of the message received are thrown away.</td>
                </tr>
                <tr>
                    <td></td>
                    <td>action</td>
                    <td>Specify an action when receiving the message. See  <a href="#actions">Actions section</a> for possible actions.</td>
                    <td>Example of a "regular expression" action:<source>&lt;recv response="200"&gt;
 &lt;action&gt;
  &lt;ereg regexp="([0-9]{1,3}\.){3}[0-9]{1,3}:[0-9]*"
    search_in="msg"
    check_it="true"
    assign_to="1,2"/&gt;
  &lt;/action&gt;
 &lt;/recv&gt;</source></td>
                </tr>
                <tr>
                    <td></td>
                    <td>next</td>
                    <td>You can put a "next" in an optional receive to go to another part of the script if you receive that message. 
                    See <a href="#branching">conditional branching</a> section for more info.</td>
                    <td>Example to jump to label "5" when receiving a 403 message:<source><![CDATA[  <recv response="100"
        optional="true">
  </recv>
  <recv response="180" optional="true">
  </recv>
  <recv response="403" optional="true" next="5">
  </recv>
  <recv response="200">
  </recv>
]]></source></td>
                </tr>
                <tr>
                    <td></td>
                    <td>test</td>
                    <td>You can put a "test" in an optional receive to go to another part of the script if you receive that message
                    only if the variable specified by "test" is set. 
                    See <a href="#branching">conditional branching</a> section for more info.</td>
                    <td>Example to jump to label "5" when receiving a 403 message only if
                    variable 3 is set:<source><![CDATA[  <recv response="100"
        optional="true">
  </recv>
  <recv response="180" optional="true">
  </recv>
  <recv response="403" optional="true" next="5" test="3">
  </recv>
  <recv response="200">
  </recv>
]]></source></td>
                </tr>
                <tr>
                    <td><strong>&lt;pause&gt;</strong></td>
                    <td>milliseconds</td>
                    <td>Specify the pause delay, in milliseconds. When this delay is not set, the value of the <code>-d</code> command
                    line parameter is used.</td>
                    <td><code>&lt;pause milliseconds="5000"/&gt;</code>: pause the scenario for 5 seconds.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>min</td>
                    <td>Indicates a minimum value for a pause. A random pause is executed between min and max values.</td>
                    <td><code>&lt;pause min="2000" max="5000"/&gt;</code> for pauses between 2 and 5 seconds.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>max</td>
                    <td>Indicates a maximum value for a pause. A random pause is executed between min and max values.</td>
                    <td><code>&lt;pause min="2000" max="5000"/&gt;</code> for pauses between 2 and 5 seconds.</td>
                </tr>            
                <tr>
                    <td></td>
                    <td>crlf</td>
                    <td>Displays an empty line <strong>after</strong> the arrow for the message in main SIPp screen.</td>
                    <td><code>&lt;pause crlf="true"&gt;</code></td>
                </tr>            
                <tr>
                    <td></td>
                    <td>next</td>
                    <td>You can put a "next" in a pause to go to another part of the script when you are done with the pause. 
                    See <a href="#branching">conditional branching</a> section for more info.</td>
                    <td>Example to jump to label "7" after pausing 4 seconds:<source><![CDATA[<pause milliseconds="4000" next="7"/>]]></source></td>
                </tr>
                <tr>
                    <td><anchor id="nop"/><strong>&lt;nop&gt;</strong></td>
                    <td>action</td>
                    <td>The nop command doesn't do anything at SIP level. It is 
                    only there to specify an action to execute. See  <a href="#actions">Actions section</a> for possible actions.</td>
                    <td>Execute the play_pcap_audio/video action:<source><![CDATA[<nop>
  <action>
    <exec play_pcap_audio="pcap/g711a.pcap"/>
  </action>
</nop>]]>
</source></td>
                </tr>            
                <tr>
                    <td><anchor id="sendCmd"/><strong>&lt;sendCmd&gt;</strong></td>
                    <td>&lt;![CDATA[]]&gt;</td>
                    <td>Content to be sent to the twin <a href="#ThreePCC">3PCC</a> SIPp instance. The Call-ID must be included in the CDATA.</td>
                    <td><source>&lt;sendCmd&gt;
  &lt;![CDATA[
    Call-ID: [call_id]
    [$1]

   ]]&gt;
&lt;/sendCmd&gt;</source></td>
                </tr>            
                <tr>
                    <td><anchor id="recvCmd"/><strong>&lt;recvCmd&gt;</strong></td>
                    <td>action</td>
                    <td>Specify an action when receiving the command. See  <a href="#actions">Actions section</a> for possible actions.</td>
                    <td>Example of a "regular expression" to retrieve what has been send by a sendCmd command:<source>&lt;recvCmd&gt;
  &lt;action
     &lt;ereg regexp="Content-Type:.*"
           search_in="msg"
           assign_to="2"/&gt;
  &lt;/action&gt;
&lt;/recvCmd&gt;</source></td>
                </tr>            
                <tr>
                    <td><strong><![CDATA[<label>]]></strong></td>
                    <td>id</td>
                    <td>A label is used when you want to branch to specific parts
                    in your scenarios. The "id" attribute is an integer where the maximum value is 19.
                    See <a href="#branching">conditional branching</a> section for more info.</td>
                    <td>Example: set label number 13:<source><![CDATA[<label id="13"/>]]></source></td>
                </tr>
                <tr>
                    <td><anchor id="resptimerep"/><strong>&lt;Response Time Repartition&gt;</strong></td>
                    <td>value</td>
                    <td>Specify the intervals, in milliseconds, used to distribute the values of response times.</td>
                    <td><code>&lt;ResponseTimeRepartition value="10, 20,
                    30"/&gt;</code>: response time values are distributed
                    between 0 and 10ms, 10 and 20ms, 20 and 30ms, 30 and
                    beyond.</td>
                </tr>            
                <tr>
                    <td><anchor id="calllengthrep"/><strong>&lt;Call Length Repartition&gt;</strong></td>
                    <td>value</td>
                    <td>Specify the intervals, in milliseconds, used to distribute the values of the call length measures.</td>
                    <td><code>&lt;CallLengthRepartition value="10, 20,
                    30"/&gt;</code>: call length values are distributed between
                    0 and 10ms, 10 and 20ms, 20 and 30ms, 30 and beyond.</td>
                </tr>
            </table>
            <p>There are not so many commands: send, recv, sendCmd, recvCmd,
            pause, ResponseTimeRepartition and CallLengthRepartition. To make
            things even clearer, nothing is better than an example...</p>
            <section><title>Structure of client (UAC like) XML scenarios</title>
            <p>A client scenario is a scenario that starts with a "send" command. So let's start:</p>
            <source>&lt;scenario name="Basic Sipstone UAC"&gt;
  &lt;send&gt;
    &lt;![CDATA[
    
      INVITE sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong> SIP/2.0
      Via: SIP/2.0/<strong>[transport]</strong> <strong>[local_ip]</strong>:<strong>[local_port]</strong>
      From: sipp &lt;sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>&gt;;tag=<strong>[call_number]</strong>
      To: sut &lt;sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong>&gt;
      Call-ID: <strong>[call_id]</strong>
      Cseq: 1 INVITE
      Contact: sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>
      Max-Forwards: 70
      Subject: Performance Test
      Content-Type: application/sdp
      Content-Length: <strong>[len]</strong>

      v=0
      o=user1 53655765 2353687637 IN IP<strong>[local_ip_type]</strong> <strong>[local_ip]</strong>
      s=-
      t=0 0
      c=IN IP<strong>[media_ip_type]</strong> <strong>[media_ip]</strong>
      m=audio <strong>[media_port]</strong> RTP/AVP 0
      a=rtpmap:0 PCMU/8000


    ]]&gt;
  &lt;/send&gt;</source>
            <p>Inside the "send" command, you have to enclose your SIP message
            between the "&lt;![CDATA" and the "]]&gt;" tags. Everything between
            those tags is going to be sent toward the remote system. You may
            have noticed that there are strange keywords in the SIP message,
            like <strong>[service], [remote_ip], ...</strong>. Those keywords
            are used to indicate to SIPp that it has to do something with
            it.</p>
            <p>Here is the list:</p>
            <anchor id="keyword"/>
            <table>
                <caption>Keyword list</caption>
                <tr>
                    <th>Keyword</th>
                    <th>Default</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><strong>[service]</strong></td>
                    <td>service</td>
                    <td>Service field, as passed in the <strong><code>-s service_name</code></strong></td>
                </tr>
                <tr>
                    <td><strong>[remote_ip]</strong></td>
                    <td>-</td>
                    <td>Remote IP address, as passed on the command line.</td>
                </tr>
                <tr>
                    <td><strong>[remote_port]</strong></td>
                    <td>5060</td>
                    <td>Remote IP port, as passed on the command line. You can 
                    add a computed offset [remote_port+3] to this value.</td>
                </tr>
                <tr>
                    <td><strong>[transport]</strong></td>
                    <td>UDP</td>
                    <td>Depending on the value of <strong>-t</strong> parameter, this will take the values "UDP" or "TCP".</td>
                </tr>
                <tr>
                    <td><strong>[local_ip]</strong></td>
                    <td>Primary host IP address</td>
                    <td>Will take the value of <strong>-i</strong> parameter.</td>
                </tr>
                <tr>
                    <td><strong>[local_ip_type]</strong></td>
                    <td>-</td>
                    <td>Depending on the address type of <strong>-i</strong> parameter (IPv4 or IPv6),
                    local_ip_type will have value "4" for IPv4 and "6" for IPv6.</td>
                </tr>
                <tr>
                    <td><strong>[local_port]</strong></td>
                    <td>Random</td>
                    <td>Will take the value of <strong>-p</strong> parameter.
                    You can add a computed offset [local_port+3] to this value.</td>
                </tr>
                <tr>
                    <td><strong>[len]</strong></td>
                    <td>-</td>
                    <td>Computed length of the SIP body. To be used in "Content-Length"
                    header. You can add a computed offset [len+3] to this value.</td>
                </tr>
                <tr>
                    <td><strong>[call_number]</strong></td>
                    <td>-</td>
                    <td>Index. The call_number starts from "1" and is incremented by 1 for each call.</td>
                </tr>
                <tr>
                    <td><strong>[cseq]</strong></td>
                    <td>-</td>
                    <td>Generates automatically the CSeq number. The initial value is 1 by default. It
                    can be changed by using the <code>-base_cseq</code> command line option.</td>
                </tr>
                <tr>
                    <td><strong>[call_id]</strong></td>
                    <td>-</td>
                    <td>A call_id identifies a call and is generated by SIPp for each new call. <strong>In client mode, it is mandatory
                    to use the value generated by SIPp in the "Call-ID" header.</strong> Otherwise, SIPp will not recognise
                    the answer to the message sent as being part of an existing call.<br/>
                    Note: [call_id] can be pre-pended with an arbitrary string using '///'. Example: Call-ID: ABCDEFGHIJ///[call_id] - it will still be recognized by SIPp as part of the same call.</td>
                </tr>
                <tr>
                    <td><strong>[media_ip]</strong></td>
                    <td>-</td>
                    <td>Depending on the value of <strong>-mi</strong> parameter, it is the local IP address for RTP echo.</td>
                </tr>
                <tr>
                    <td><strong>[media_ip_type]</strong></td>
                    <td>-</td>
                    <td>Depending on the address type of <strong>-mi</strong> parameter (IPv4 or IPv6),
                    media_ip_type will have value "4" for IPv4 and "6" for IPv6. Useful to build the SDP independently
                    of the media IP type.</td>
                </tr>
                <tr>
                    <td><strong>[media_port]</strong></td>
                    <td>-</td>
                    <td>Depending on the value of <strong>-mp</strong> parameter, it set the local RTP echo port number. Default
                      is none. RTP/UDP packets received on that port are echoed to their sender. You can 
                    add a computed offset [media_port+3] to this value.</td>
                </tr>
                <tr>
                    <td><strong>[last_*]</strong></td>
                    <td>-</td>
                    <td>The '[last_*]' keyword is replaced automatically by the
                    specified header if it was present in the last message
                    received (except if it was a retransmission). If the header
                    was not present or if no message has been received, the
                    '[last_*]' keyword is discarded, and all bytes until the end
                    of the line are also discarded. If the specified header was
                    present several times in the message, all occurences are
                    concatenated (CRLF separated) to be used in place of the
                    '[last_*]' keyword.</td>
                </tr>
                <tr>
                    <td><strong>[field0-n]</strong></td>
                    <td>-</td>
                    <td>Used to inject values from an external CSV file. See
                    <a href="#inffile">"Injecting values from an external CSV
                    during calls"</a> section.</td>
                </tr>
                <tr>
                    <td><strong>[$n]</strong></td>
                    <td>-</td>
                    <td>Used to inject the value of call variable number n. See "<a href="#actions">Actions</a>" section</td>
                </tr>
                <tr>
                    <td><strong>[authentication]</strong></td>
                    <td>-</td>
                    <td>Used to put the authentication header. This field can have parameters, in the following form: 
                    [authentication username=myusername password=mypassword]. If no username is provided, 
                    the value from -s command line parameter (service) is used.  If no password is provided, the value 
                    from -ap command line parameter is used. See "<a href="#authentication">Authentication</a>" section</td>
                </tr>
                <tr>
                    <td><strong>[pid]</strong></td>
                    <td>-</td>
                    <td>Provide the process ID (pid) of the main SIPp thread.</td>
                </tr>
                <tr>
                    <td><strong>[routes]</strong></td>
                    <td>-</td>
                    <td>If the "rrs" attribute in a recv command is set to "true",
                    then the "Record-Route:" header of the message received is stored 
                    and can be recalled using the [routes] keyword</td>
                </tr>
                <tr>
                    <td><strong>[next_url]</strong></td>
                    <td>-</td>
                    <td>If the "rrs" attribute in a recv command is set to "true",
                    then the [next_url] contains the contents of the Contact header 
                    (i.e within the '&lt;' and '&gt;' of Contact)</td>
                </tr>
                <tr>
                    <td><strong>[branch]</strong></td>
                    <td>-</td>
                    <td>Provide a branch value which is a concatenation of magic cookie 
                    (z9hG4bK) + call number + message index in scenario.</td>
                </tr>
                <tr>
                    <td><strong>[msg_index]</strong></td>
                    <td>-</td>
                    <td>Provide the message number in the scenario.</td>
                </tr>
                <tr>
                    <td><strong>[cseq]</strong></td>
                    <td>-</td>
                    <td>Provides the CSeq value of the last request received. This value can be incremented (e.g. [cseq+1] adds 1 to
                        the CSeq value of the last request).</td>
                </tr>
            </table>
            <p>Now that the INVITE message is sent, SIPp can wait for an answer by using the "<a href="#recv">recv</a>" command.</p>
<source>  &lt;recv response="100"&gt; optional="true"
  &lt;/recv&gt;

  &lt;recv response="180"&gt; optional="true"
  &lt;/recv&gt;

  &lt;recv response="200"&gt;
  &lt;/recv&gt;</source>
            <p>100 and 180 messages are optional, and 200 is mandatory. 
            <strong>In a "recv" sequence, there must be one mandatory message</strong>.</p>
            <p>Now, let's send the ACK:</p>
<source>  &lt;send&gt;
    &lt;![CDATA[

      ACK sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong> SIP/2.0
      Via: SIP/2.0/<strong>[transport]</strong> <strong>[local_ip]</strong>:<strong>[local_port]</strong>
      From: sipp &lt;sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>&gt;;tag=<strong>[call_number]</strong>
      To: sut &lt;sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port</strong>]&gt;<strong>[peer_tag_param]</strong>
      Call-ID: <strong>[call_id]</strong>
      Cseq: 1 ACK
      Contact: sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>
      Max-Forwards: 70
      Subject: Performance Test
      Content-Length: 0

    ]]&gt;
  &lt;/send&gt;</source>
            <p>We can also insert a pause. The scenario will wait for 5 seconds at this point.</p>
<source>  &lt;pause milliseconds="5000"/&gt;</source>
            <p>And finish the call by sending a BYE and expecting the 200 OK:</p>
<source>    &lt;send retrans="500"&gt;
     &lt;![CDATA[

      BYE sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong> SIP/2.0
      Via: SIP/2.0/<strong>[transport] [local_ip]</strong>:<strong>[local_port]</strong>
      From: sipp  &lt;sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>&gt;;tag=<strong>[call_number]</strong>
      To: sut  &lt;sip:<strong>[service]</strong>@<strong>[remote_ip]</strong>:<strong>[remote_port]</strong>&gt;<strong>[peer_tag_param]</strong>
      Call-ID: <strong>[call_id]</strong>
      Cseq: 2 BYE
      Contact: sip:sipp@<strong>[local_ip]</strong>:<strong>[local_port]</strong>
      Max-Forwards: 70
      Subject: Performance Test
      Content-Length: 0

    ]]&gt;
   &lt;/send&gt;

   &lt;recv response="200"&gt;
   &lt;/recv&gt;</source>
            <p>And this is the end of the scenario:</p>
<source>&lt;/scenario&gt;</source>
            <p>Creating your own SIPp scenarios is not a big deal. 
            If you want to see other examples, use the <code>-sd</code> parameter
            on the command line to display embedded scenarios.</p>
            </section>
            <section><title>Structure of server (UAS like) XML scenarios</title>
            <p>A server scenario is a scenario that starts with a "<a href="#recv">recv</a>" command. 
            The syntax and the list of available commands is the same as for
            "client" scenarios.</p>
            <p>But you are more likely to use [last_*] keywords in those server
            side scenarios. For example, a UAS example will look like:</p>
<source>  &lt;recv request="INVITE"&gt;
  &lt;/recv&gt;

  &lt;send&gt;
    &lt;![CDATA[

      SIP/2.0 180 Ringing
      <strong>[last_Via:]</strong>
      <strong>[last_From:]</strong>
      <strong>[last_To:]</strong>;tag=<strong>[call_number]</strong>
      <strong>[last_Call-ID:]</strong>
      <strong>[last_CSeq:]</strong>
      Contact: &lt;sip:<strong>[local_ip]</strong>:<strong>[local_port]</strong>;transport=<strong>[transport]</strong>&gt;
      Content-Length: 0

    ]]&gt;
  &lt;/send&gt;</source>
            <p>The answering message, 180 Ringing in this case, is built
            with the content of headers received in the INVITE message.</p>
            </section>
            <anchor id="actions" /><section><title>Actions</title>
              <p>In a "<a href="#recv">recv</a>" or "<a href="#recvCmd">recvCmd</a>" command, you have the possibility to
              execute an action. Since version 1.1, several actions are available:</p>
              <ul>
                <li><a href="#action_regexp">Regular expressions</a> (ereg)</li>
                <li><a href="#action_log">Log something in aa log file</a> (log)</li>
                <li><a href="#action_exec">Execute an external (system), internal (int_cmd) or 
                pcap_play_audio/pcap_play_video command</a> (exec)</li>
              </ul>
                <anchor id="action_regexp" /><section><title>Regular expressions</title>
                  <p>Using regular expressions in SIPp allows to</p>
                  <ul>
                     <li>Extract content of a SIP message or a SIP header and
                     store it for future usage (called re-injection)</li>
                     <li>Check that a part of a SIP message or of an header 
                     is matching an expected expression</li>
                  </ul>
                  <p>Regular expressions used in SIPp are defined per 
                  <a href="http://www.opengroup.org/onlinepubs/007908799/xbd/re.html">
                  Posix Extended standard (POSIX 1003.2)</a>. If you want to
                  learn how to write regular expressions, I will recommend 
                  this <a href="http://analyser.oli.tudelft.nl/regex/index.html.en">
                  regexp tutorial</a>.</p>
                  <p>Here is the syntax of the regexp action:</p>
                  <table>
                      <caption>regexp action syntax</caption>
                      <tr>
                          <th>Keyword</th>
                          <th>Default</th>
                          <th>Description</th>
                      </tr>
                      <tr>
                          <td>regexp</td>
                          <td>None</td>
                          <td>Contains the regexp to use for matching the 
                          received message or header. MANDATORY.</td>
                      </tr>
                      <tr>
                          <td>search_in</td>
                          <td>msg</td>
                          <td>can have 2 values: "msg" (try to match against 
                          the entire message) or "hdr" (try to match against a specific SIP header).</td>
                      </tr>
                      <tr>
                          <td>header</td>
                          <td>None</td>
                          <td>Header to try to match against. Only used when 
                          the search_in tag is set to hdr. MANDATORY IF 
                          search_in is equal to hdr.</td>
                      </tr>
                      <tr>
                          <td>check_it</td>
                          <td>false</td>
                          <td>if set to true, the call is marked as failed if 
                          the regexp doesn't match.</td>
                      </tr>
                      <tr>
                          <td>assign_to</td>
                          <td>None</td>
                          <td>contain the variable id (integer) or a list of 
                          variable id which will be used to store the 
                          result(s) of the matching process between the regexp 
                          and the message. Those variables can be re-used at 
                          a later time either by using '[$n]' in the scenario 
                          to inject the value of the variable in the messages or
                          by using the content of the variables for <a href="#branching">conditional 
                          branching</a>. The first variable in the variable list of
                          assign_to contains the entire regular
                          expression matching. The following variables contain the
                          sub-expressions matching. Example: <source><![CDATA[<ereg regexp="o=([[:alnum:]]*) ([[:alnum:]]*) ([[:alnum:]]*)"
            search_in="msg"
            check_it=i"true"
            assign_to="3,4,5,8"/>]]></source>If the SIP message contains the line <source>o=user1 53655765 2353687637 IN IP4 127.0.0.1</source>
            variable 3 contains "o=user1 53655765 2353687637", variable 4 contains "user1", 
            variable 5 contains "53655765" and variable 8 contains "2353687637".</td>
                      </tr>
                  </table>
                  <p>Note that you can have several regular expressions
                  in one action.</p>
                  <p>The following example is used to:</p>
                  <ul>
                    <li>First action:
                      <ul>
                        <li>Extract the first IPv4 address of the received SIP message</li>
                        <li>Check that we could actually extract this IP address (otherwise
                        call will be marked as failed)</li>
                        <li>Assign the extracted IP address to call variables 1
                        and 2.</li>
                      </ul>
                    </li>
                    <li>Second action:
                      <ul>
                        <li>Extract the Contact: header of the received SIP message</li>
                        <li>Assign the extracted Contract: header to variable 6.</li>
                      </ul>
                    </li>
                  </ul>
                  <source>
&lt;recv response="200" start_rtd="true"&gt;
  &lt;action&gt;
    &lt;ereg regexp="([0-9]{1,3}\.){3}[0-9]{1,3}:[0-9]*" search_in="msg" check_it="true" assign_to="1,2" /&gt; 
    &lt;ereg regexp=".*" search_in="hdr" header="Contact:" check_it="true" assign_to="6" /&gt;
  &lt;/action&gt;
&lt;/recv&gt;
</source>
                </section>
                <anchor id="action_log" /><section><title>Log a message</title>
                  <p>The "log" action allows you to customize your traces. Messages
                  are printed in the <![CDATA[<scenario file name>_<pid>_logs.log]]> file.
                  Any <a href="#keyword">keyword</a> is expanded to reflect the value actually used.</p>
                  <warning>Logs are generated only if -trace_logs option is set on
                  the command line.</warning>
                  <p>Example:</p>
                  <source><![CDATA[   <recv request="INVITE" crlf="true" rrs="true">
     <action>
	 <ereg regexp=".*" search_in="hdr" header="Some-New-Header:" assign_to="1" />
          <log message="From is [last_From]. Custom header is [$1]"/>
     </action>
   </recv>]]></source>
                </section>
                <anchor id="action_exec" /><section><title>Execute a command</title>
                  <p>The "exec" action allows you to execute "internal", "external", "play_pcap_audio" or "play_pcap_video" commands.</p>
                  <ul>
                    <li><strong>Internal</strong> commands (specified using int_cmd attribute) are stop_call, stop_gracefully (similar to pressing 'q'), stop_now (similar to ctrl+C).</li>
                    <li><strong>External</strong> commands (specified using command attribute) are anything that can be executed on local host with a shell.</li>
                    <li><strong>PCAP play</strong> commands (specified using play_pcap_audio / play_pcap_video attributes) 
                    allow you to send a pre-recorded RTP stream using the <a href="http://www.tcpdump.org/pcap3_man.html">pcap library</a>.
                      <p>Choose <strong>play_pcap_audio</strong> to send the pre-recorded RTP stream using the "m=audio" SIP/SDP line port as a base for the replay.</p>
                      <p>Choose <strong>play_pcap_video</strong> to send the pre-recorded RTP stream using the "m=video" SIP/SDP line port as a base.</p> 
                      <p>The play_pcap_audio/video command has the following format: play_pcap_audio="[file_to_play]" with:</p>
                          <ul>
                            <li>file_to_play: the pre-recorded pcap file to play</li>
                          </ul>
                          <note>The action is non-blocking. SIPp will start a light-weight thread to play the file 
                          and the scenario with continue immediately. If needed, you will need to add a pause
                          to wait for the end of the pcap play.</note>
                       </li>
                  </ul>
                  <p>Example that stops the execution of the script on receiving a 603 response:</p>
                  <source><![CDATA[   <recv response="603" optional="true">
     <action>
          <exec int_cmd="stop_now"/>
      </action>
   </recv>]]></source>
                  <p>Example that execute a system echo for every INVITE received:</p>
                  <source><![CDATA[   <recv request="INVITE">
     <action>
          <exec command="echo [last_From] is the from header received >> from_list.log"/>
      </action>
   </recv>]]></source>
                  <p>Example that plays a pre-recorded RTP stream:</p>
                  <source><![CDATA[<nop>
  <action>
    <exec play_pcap_audio="pcap/g711a.pcap"/>
  </action>
</nop>
]]></source>
                </section>
            </section>
            <anchor id="inffile" /><section><title>Injecting values from an external CSV during calls</title>
                <p>You can use "<code>-inf file_name</code>" as a command line parameter
                to input values into the scenarios. The first line of the file should
                say whether the data is to be read in sequence (SEQUENTIAL) or random
                (RANDOM) order. Each line corresponds to one call and has one or more
                ';' delimited data fields and they can be referred as [field0], [field1], ... in the
                xml scenario file. Example:</p>
<source>SEQUENTIAL
#This line will be ignored
Sarah;sipphone32
Bob;sipphone12
#This line too
Fred;sipphone94</source>
                <p>Will be read in sequence (first call will use first line,
                second call second line). At any place where the keyword
                "[field0]" appears in the scenario file, it will be replaced by
                either "Sarah", "Bob" or "Fred" depending on the call. At any
                place where the keyword "[field1]" appears in the scenario file,
                it will be replaced by either "sipphone32" or "sipphone12" or
                "sipphone94" depending on the call. At the end of the file, SIPp
                will re-start from the beginning. The file is not limited in
                size.</p>
                <p>The CSV file can contain comment lines. A comment line is
                a line that starts with a "#".</p>
                <p>As a picture says more than 1000 words, here is one:</p>
                <p><img src="images/sipp-02.gif" alt="Field injection" /></p>
                <p>Think of the possibilities of this feature. They are huge.</p>
            </section>
            <anchor id="branching" /><section><title>Conditional branching in scenarios</title>
              <p>Since version 1.1, it is possible to execute a scenario in a non-linear
              way. You can jump from one part of the scenario to another for example 
              when a message is received or if a call variable is set.</p>
              <p>You define a label (in the xml) as <code><![CDATA[<label id="n"/>]]></code>
              Where n is a number between 1 and 19 (we can easily have more if needed). 
              The label commands go anywhere in the main scenario between other commands.
              To any action command (send, receive, pause, etc.) you add a next="n"
              parameter, where n matches the id of a label. <strong>When it has done the 
              command</strong> it continues the scenario from that label. This part is
              useful with optional receives like 403 messages, because it allows 
              you to go to a different bit of script to reply to it and then 
              rejoin at the BYE (or wherever or not).</p>
              <p>Alternatively, if you add a <strong>test="m"</strong> parameter to the next, 
              it goes to the label only if variable [$m] is set. This allows you 
              to look for some string in a received packet and alter the 
              flow either on that or a later part of the script.</p>
              <warning>If you add special cases at the end, dont forget to put 
              a label at the real end and jump to it at the end of the normal flow.</warning>
              <p><strong>Example:</strong></p>
              <p>The following example corresponds to the embedded '<a href="#scenario_branch">branchc</a>' (client side) scenario.
              It has to run against the embedded '<a href="#scenario_branch">branchs</a>' (server side) scenario.<br/>
              <img alt="Conditional branching example" src="images/branching_01.gif"></img><br/>
              <img alt="Conditional branching example" src="images/branching_02.gif"></img></p>
            </section>
            <anchor id="authentication"/><section><title>SIP authentication</title>
              <p>Since version 1.1, SIPp supports SIP authentication. The supported
              authentication scheme is Digest/MD5.</p>
              <warning>To enable authentication support, SIPp must be compiled in a
              special way. See <a href="#installing">SIPp installation</a>
              for details</warning>
              <p>Enabling authentication is simple. When receiving a 401 (Unauthorized)
              or a 407 (Proxy Authentication Required), you must add auth="true"
              in the <![CDATA[<recv>]]> command to take the challenge into account.
              Then, the authorization header can be re-injected in the next message
              by using <![CDATA[[authentication]]]> keyword.</p>
              <p>To compute the authorization header, you must specify a username and
              password. This is done with the "[authentication]" keyword:</p>
              <source>[authentication username=myusername password=mypassword]</source>
              <p>If no username is specified, the username is taken from the '-s' (service) command
              line parameter. If no password is specified, the password is taken from the '-ap' (authentication
              password) command line parameter.</p>
              <p>In case you want to use authentication with a different username and password
              for each call, you can do this:</p>
              <ul>
                <li>Make a CSV like this: 
                <source>SEQUENTIAL
User0001;[authentication username=joe password=schmo]
User0002;[authentication username=john password=smith]
User0003;[authentication username=betty password=boop]</source>
                </li>
                <li>And an XML like this (the [field1] will be substituted with the full auth string, which is the processed as a new keyword):
                <source><![CDATA[<send retrans="500">
    <![CDATA[

      REGISTER sip:[remote_ip] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port]
      To: <sip:[field0]@sip.com:[remote_port]>
      From: <sip:[field0]@[remote_ip]:[remote_port]>
      Contact: <sip:[field0]@[local_ip]:[local_port]>;transport=[transport]
      [field1]
      Expires: 300
      Call-ID: [call_id]
      CSeq: 2 REGISTER
      Content-Length: 0

    ]]>]]<![CDATA[>
  </send>]]>
</source>
                </li>
              </ul>
              <p><strong>Example:</strong></p>
<source><![CDATA[  <recv response="407" ]]><strong>auth="true"</strong><![CDATA[>
  </recv>

  <send>
    <![CDATA[

      ACK sip:[service]@[remote_ip]:[remote_port] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port]
      From: sipp <sip:sipp@[local_ip]:[local_port]>;tag=[call_number]
      To: sut <sip:[service]@[remote_ip]:[remote_port]>[peer_tag_param]
      Call-ID: [call_id]
      CSeq: 1 ACK
      Contact: sip:sipp@[local_ip]:[local_port]
      Max-Forwards: 70
      Subject: Performance Test
      Content-Length: 0

    ]]>]]&gt;<![CDATA[
  </send>

  <send retrans="500">
    <![CDATA[

      INVITE sip:[service]@[remote_ip]:[remote_port] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port]
      From: sipp <sip:sipp@[local_ip]:[local_port]>;tag=[call_number]
      To: sut <sip:[service]@[remote_ip]:[remote_port]>
      Call-ID: [call_id]
      CSeq: 2 INVITE
      Contact: sip:sipp@[local_ip]:[local_port]
      ]]><strong>[authentication username=foouser]</strong><![CDATA[
      Max-Forwards: 70
      Subject: Performance Test
      Content-Type: application/sdp
      Content-Length: [len]

      v=0
      o=user1 53655765 2353687637 IN IP[local_ip_type] [local_ip]
      s=-
      t=0 0
      c=IN IP[media_ip_type] [media_ip]
      m=audio [media_port] RTP/AVP 0
      a=rtpmap:0 PCMU/8000

    ]]>]]&gt;<![CDATA[
  </send>

]]></source>
            </section>
        </section>
        <section><title>Screens</title>
            <p>Several screens are available to monitor SIP traffic. You can 
            change the screen view by pressing 1 to 9 keys on the keyboard.</p>
            <ul>
                <li>Key '1': Scenario screen. It displays a call flow of
                the scenario as well as some important informations.
                <p><img src="images/sipp-03.jpg" alt="Scenario screen" /></p>
                </li>
                <li><anchor id="stat_screen" />Key '2': Statistics screen. It displays the main statistics
                counters. The "Cumulative" column gather all statistics, since
                SIPp has been launched. The "Periodic" column gives the statistic
                value for the period considered (specified by <code>-f frequency</code> command
                line parameter).
                <p><img src="images/sipp-04.jpg" alt="Statistics screen" /></p>
                </li>
                <li>Key '3': Repartition screen. It displays the distribution
                of response time and call length, as specified in the scenario.
                <p><img src="images/sipp-05.jpg" alt="Repartition screen" /></p></li>
                <li>Key '4': Variables screen. It displays informations on
                actions in scenario as well as scenario variable informations.
                <p><img src="images/sipp-06.jpg" alt="Variables screen " /></p></li>
            </ul>
        </section>
        <section><title>Transport modes</title>
            <p>SIPp has several transport modes. The default transport mode is 
            "UDP mono socket".</p>
            <section><title>UDP mono socket</title>
                <p>In UDP mono socket mode (<code>-t u1</code> command line parameter),
                one IP/UDP socket is opened between SIPp and the remote. All calls
                are placed using this socket.</p>
                <note>This mode is generally used for emulating a relation
                between 2 SIP servers.</note>
            </section>
            <section><title>UDP multi socket</title>
                <p>In UDP multi socket mode (<code>-t un</code> command line parameter),
                one IP/UDP socket is opened for each new call between SIPp and the remote.</p>
                <note>This mode is generally used for emulating user agents calling a SIP server.</note>
            </section>
            <section><title>TCP mono socket</title>
                <p>In TCP mono socket mode (<code>-t t1</code> command line parameter),
                one IP/TCP socket is opened between SIPp and the remote. All calls
                are placed using this socket.</p>
                <note>This mode is generally used for emulating a relation between 2 SIP servers.</note>
            </section>
            <section><title>TCP multi socket</title>
                <p>In TCP multi socket mode (<code>-t tn</code> command line parameter),
                one IP/TCP socket is opened for each new call between SIPp and the remote.</p>
                <note>This mode is generally used for emulating user agents calling a SIP server.</note>
            </section>
            <anchor id="tls" /><section><title>TLS mono socket</title>
                <p>In TLS mono socket mode (<code>-t l1</code> command line parameter),
                one secured TLS (Transport Layer Security) socket is opened between SIPp and the remote. All calls
                are placed using this socket.</p>
                <note>This mode is generally used for emulating a relation between 2 SIP servers.</note>
                <warning>When using TLS transport, SIPp will expect to have two files in the current
                directory: a certificate (cacert.pem) and a key (cakey.pem). 
                If one is protected with a password, SIPp will
                ask for it.</warning>
                <p>SIPp supports X509's CRL (Certificate Revocation List). The CRL is 
                read and used if <code>-tls_crl</code> command line specifies
                a CRL file to read.</p>
            </section>
            <section><title>TLS multi socket</title>
                <p>In TLS multi socket mode (<code>-t ln</code> command line parameter),
                one secured TLS (Transport Layer Security) socket is opened for each new call between SIPp and the remote.</p>
                <note>This mode is generally used for emulating user agents calling a SIP server.</note>
            </section>
            <anchor id="ipv6" /><section><title>IPv6 support</title>
                <p>SIPp 1.1 introduces IPv6 support. To use IPv6, just specify the local
                IP address (-i command line parameter) to be an IPv6 IP address.</p>
                <p>The following example launches a UAS server listening on port 5063 and a UAC client sending
                IPv6 traffic to that port.</p>
                <source><![CDATA[./sipp -sn uas -i [fe80::204:75ff:fe4d:19d9] -p 5063
./sipp -sn uac -i [fe80::204:75ff:fe4d:19d9] [fe80::204:75ff:fe4d:19d9]:5063]]>
                </source>
            </section>
            <anchor id="maxsocket" /><section><title>Multi-socket limit</title>
                <p>When using one of the "multi-socket" transports, the maximum number of sockets that can be opened
                (which corresponds to the number of simultaneous calls) will be determined by
                the system (see <a href="#filedesc">how to increase file descriptors section</a> to
                modify those limits). You can also limit the number of socket used by using the <code>-max_socket</code>
                command line option. Once the maximum number of opened sockets is reached,
                the traffic will be distributed over the sockets already opened.
                </p>
            </section>
        </section>
        <section><title>Handling media with SIPp</title>
          <p>SIPp is originally a signalling plane traffic generator. There is a limited
          support of media plane (RTP).</p>
          <section><title>RTP echo</title>
            <p>The "RTP echo" feature allows SIPp to listen to one or two local IP
            address and port (specified using <code>-mi</code> and
            <code>-mp</code> command line parameters) for RTP media. Everything
            that is received on this address/port is echoed back to the
            sender.</p>
            <p>RTP/UDP packets coming on this port + 2 are also echoed to their sender (used for
            sound and video echo).</p>
          </section>
          <anchor id="pcapplay" /><section><title>PCAP Play</title>
            <p>The PCAP play feature makes use of the <a href="http://www.tcpdump.org/pcap3_man.html">PCAP library</a>
            to replay pre-recorded RTP streams towards a destination. RTP streams can be 
            recorded by tools like <a href="http://www.wireshark.org/">Wireshark</a>
            (formerly known as Ethereal) or <a href="http://www.tcpdump.org/">tcpdump</a>. This allows you to:</p>
            <ul>
              <li>Play any RTP stream (voice, video, voice+video, out of band DTMFs/RFC 2833, T38 fax, ...)</li>
              <li>Use any codec as the codec is not handled by SIPp</li>
              <li>Emulate precisely the behavior of any SIP equipment as the 
              pcap play will try to replay the RTP stream as it was recorded (limited
              to the performances of the system).</li>
              <li>Reproduce exactly what has been captured using an IP sniffer like <a href="http://www.wireshark.org/">Wireshark</a>.</li>
            </ul>
            <p>A good example is the <a href="#uac_with_media">UAC with media</a> (uac_pcap) embedded scenario.</p>
            <p>SIPp comes with a G711 alaw pre-recorded pcap file and 
            out of band (RFC 2833) DTMFs in the pcap/ directory.</p>
            <warning>The PCAP play feature uses pthread_setschedparam calls from pthread library. 
            Depending on the system settings, you might need to be root to allow this. Please
            check "man 3 pthread_setschedparam" man page for details</warning>
            <p>More details on the possible PCAP play actions can be found in the <a href="#action_exec">action reference section</a>.</p>
            <p>The latest info on this feature, tips and tricks can be found on <a href="http://sipp.sourceforge.net/wiki/index.php/Pcapplay" >SIPp wiki</a>.</p>
          </section>
        </section>
        <section><title>Exit codes</title>
            <p>To ease automation of testing, upon exit (on fatal error or when
            the number of asked calls (<code>-m</code> command line option) is
            reached, sipp exits with one of the following exit codes:</p>
            <ul>
                <li>0: All calls were successful</li>
                <li>1: At least one call failed</li>
                <li>97: exit on internal command. Calls may have been processed</li>
                <li>99: Normal exit without calls processed</li>
                <li>-1: Fatal error</li>
            </ul>
            <p>Depending on the system that SIPp is running on, you can echo
            this exit code by using "<code>echo ?</code>" command.</p>
        </section>
        <section><title>Statistics</title>
            <section><title>Available counters</title>
                <p>The <code>-trace_stat</code> option dumps all statistics in
                the scenario_name_pid.csv file. The dump starts with one header line
                with all counters. All following lines are 'snapshots' of
                statistics counter given the statistics report frequency (-fd
                option). When SIPp exits, the last values of the statistics
                are also dumped in this file.</p>
                <p>This file can be easily imported in any spreadsheet
                application, like Excel.</p>
                <p>In counter names, (P) means 'Periodic' - since last statistic
                row and (C) means 'Cumulated' - since sipp was started.</p>
<anchor id="stats" /><p>Available statistics are:</p>
  <ul>
    <li>StartTime: 
    Date and time when the test has started.</li>
    <li>LastResetTime:
    Date and time when periodic counters where last reseted.</li>
    <li>CurrentTime:
    Date and time of the statistic row.</li>
    <li>ElapsedTime:
    Elapsed time.</li>
    <li>CallRate:
    Call rate (calls per seconds).</li>
    <li>IncomingCall:
    Number of incoming calls.</li>
    <li>OutgoingCall:
    Number of outgoing calls.</li>
    <li>TotalCallCreated:
    Number of calls created.</li>
    <li>CurrentCall:
    Number of calls currently ongoing.</li>
    <li>SuccessfulCall:
    Number of successful calls.</li>
    <li>FailedCall:
    Number of failed calls (all reasons).</li>
    <li>FailedCannotSendMessage:
    Number of failed calls because Sipp cannot send the
    message (transport issue).</li>
    <li>FailedMaxUDPRetrans:
    Number of failed calls because the maximum number of
    UDP retransmission attempts has been reached.</li>
    <li>FailedUnexpectedMessage:
    Number of failed calls because the SIP message received
    is not expected in the scenario.</li>
    <li>FailedCallRejected:
    Number of failed calls because of Sipp internal error.
    (a scenario sync command is not recognized or a scenario
    action failed or a scenario variable assignment failed).</li>
    <li>FailedCmdNotSent:
    Number of failed calls because of inter-Sipp
    communication error (a scenario sync command failed to
    be sent).</li>
    <li>FailedRegexpDoesntMatch:
    Number of failed calls because of regexp that doesn't
    match (there might be several regexp that don't match
    during the call but the counter is increased only by
    one).</li>
    <li>FailedRegexpHdrNotFound:
    Number of failed calls because of regexp with hdr    
    option but no matching header found.</li>
    <li>OutOfCallMsgs:
    Number of SIP messages received that cannot be associated
    with an existing call.</li>
    <li>AutoAnswered:
    Number of unexpected specific messages received for new Call-ID.
    The message has been automatically answered by a 200 OK
    Currently, implemented for 'PING' message only.</li>
    </ul>
    <p>In addition, two other statistics are gathered:</p>
    <ul>
    <li>ResponseTime: this is the timer between two send or recv
    commands that have the <a href="#start_rtd">start_rtd</a> or
    <a href="#rtd">rtd</a> attributes. This is used to measure the time 
    between two messages.</li>
    <li>CallLength: this is the time of the duration of an entire call.</li>
    </ul>
    <p>Both ResponseTime and CallLength statistics can be tuned using <a href="#resptimerep">ResponseTimeRepartition</a>
    and <a href="#calllengthrep">CallLengthRepartition</a> commands in the scenario.</p>
            </section>
            <section><title>Importing statistics in spreadsheet applications</title>
                <section><title>Example: importation in Microsoft Excel</title>
                  <p>Here is a video (Windows Media Player 9 codec or above
                  required) on how to import CSV statistic files in Excel and
                  create a graph of failed calls over time.</p>
                  <p><icon src="images/wmv.gif" alt="wmv" /><a href="images/sipp-02.wmv">sipp-02.wmv</a></p>
                </section>
            </section>
        </section>
        <section><title>Error handling</title>
            <p>SIPp has advanced feature to handle errors and unexpected events. 
            They are detailed in the following sections.</p>
            <section><title>Unexpected messages</title>
                <ul>
                    <li>When a SIP message that <strong>can</strong> be
                    correlated to an existing call (with the
                    <code>Call-ID:</code> header) but is not expected in the
                    scenario is received, SIPp will send a CANCEL message if no
                    200 OK message has been received or a BYE message if a 200
                    OK message has been received. The call will be marked 
                    as failed. If the unexpected message is a 4XX or 5XX,
                    SIPp will send an ACK to this message, close the call
                    and mark the call as failed.</li>
                    <li>When a SIP message that <strong>can't</strong> be
                    correlated to an existing call (with the
                    <code>Call-ID:</code> header) is received, SIPp will send a
                    BYE message. The call will not be counted at all.</li>
                    <li>When a SIP "PING" message is received, SIPp will send
                    an ACK message in response. This message is not counted as 
                    being an unexpected message. But it is counted in the "AutoAnswered"
                    <a href="#stats">statistic counter</a>.
                    </li>
                    <li>An unexpected message that is not a SIP message will
                    be simply dropped.</li>
                </ul>
            </section>
            <section><title>Retransmissions (UDP only)</title>
                <p>A retransmission mechanism exists in UDP transport mode. 
                To activate the retransmission mechanism, the "send" command must include
                the "retrans" attribute.</p>
                <p>When it is activated and a SIP message is sent and no ACK or
                response is received in answer to this message, the message is
                re-sent.</p>
                <note>The retransmission mechanism follows RFC 3261, section 17.1.1.2. 
                Retransmissions are differentiated between INVITE and non-INVITE 
                methods.</note>
                <p><code>&lt;send retrans="500"&gt;</code>: will initiate the T1 timer
                to 500 milliseconds.</p>
                <p>Even if retrans is specified in your scenarios, you can override this by 
                using the <code>-nr</code> command line option to globally disable the
                retransmission mechanism.</p>
            </section>
            <section><title>Log files (error + log + screen)</title>
                <p>There are several ways to trace what is going on during your SIPp runs.</p>
                <ul>
                    <li>You can log sent and received SIP messages in &lt;name_of_the_scenario&gt;_&lt;pid&gt;_messages.log by
                    using the command line parameter <code>-trace_msg</code>. The messages are time-stamped so that you
                    can track them back.</li>
                    <li>You can trace all unexpected messages or events in &lt;name_of_the_scenario&gt;_&lt;pid&gt;_errors.log by using
                    the command line parameter <code>-trace_err</code>.</li>
                    <li>You can save in a file the statistics screens, as displayed in
                    the interface. This is especially useful when running SIPp in background
                    mode.<br/>
                    This can be done in two ways:
                    <ul>
                      <li>When SIPp exits to get a final status report (-trace_screen option)</li>
                      <li>On demand by using USR2 signal (example: <code>kill -SIGUSR2 738</code>)</li>
                    </ul>
                    </li>
                    <li>You can log all call ids for calls that timeout (the maximum
                    number of retransmissions for UDP transport is reached)
                    by using the command line parameter <code>-trace_timeout</code></li>
                </ul>
            </section>
        </section>
        <section><title>Online help (-h)</title>
          <p>The online help, available through the -h option is duplicated here for your
          convenience</p>
          <source><![CDATA[Usage:

  sipp remote_host[:remote_port] [options]

  Available options:

   -v               : Display version and copyright information.

   -bg              : Launch SIPp in background mode.

   -p local_port    : Set the local port number. Default is a
                      random free port chosen by the system.

   -i local_ip      : Set the local IP address for 'Contact:',
                      'Via:', and 'From:' headers. Default is
                      primary host IP address.

   -bind_local      : Bind socket to local IP address, i.e. the local IP
                      address is used as the source IP address.
                      If SIPp runs in server mode it will only listen on the
                      local IP address instead of all IP addresses.

   -inf file_name   : Inject values from an external CSV file during calls
                      into the scenarios.
                      First line of this file say whether the data is 
                      to be read in sequence (SEQUENTIAL) or random 
                      (RANDOM) order.
                      Each line corresponds to one call and has one or 
                      more ';' delimited data fields. Those fields can be 
                      referred as [field0], [field1], ... in the xml 
                      scenario file.

   -d duration      : Controls the length (in milliseconds) of
                      calls. More precisely, this controls
                      the duration of 'pause' instructions in
                      the scenario, if they do not have a
                      'milliseconds' section. Default value is 0.

   -r rate (cps)    : Set the call rate (in calls per seconds).
                      This value can be changed during test by
                      pressing '+','_','*' or '/'. Default is 10.
                      pressing '+' key to increase call rate by 1,
                      pressing '-' key to decrease call rate by 1,
                      pressing '*' key to increase call rate by 10,
                      pressing '/' key to decrease call rate by 10.
                      If the -rp option is used, the call rate is
                      calculated with the period in ms given 
                      by the user.

   -rp period (ms)  : Specify the rate period in milliseconds for the call
                      rate.
                      Default is 1 second.
                      This allows you to have n calls every m milliseconds 
                      (by using -r n -rp m).
                      Example: -r 7 -rp 2000 ==> 7 calls every 2 seconds.

   -max_socket max  : Set the max number of sockets to open simultaneously.
                      This option is significant if you use one socket
                      per call. Once this limit is reached, traffic is
                      distributed over the sockets already opened.
                      Default value is 50000.

   -timer_resol     : Set the timer resolution in milliseconds.
                      This option has an impact on timers precision.
                      Small values allow more precise scheduling but
                      impacts CPU usage.
                      If the compression is on, the value is set to 50ms.
                      The default value is 200ms.

   -max_recv_loops  : Set the maximum number of messages received read per
                      cycle. Increase this value for high traffic level.
                      The default value is 1000.

   -up_nb           : Set the number of updates of the internal clock during
                      the reading of received messages.
                      Default value is 1.

   -base_cseq n     : Start value of [cseq] for each call.

   -auth_uri uri    : Force the value of the URI for authentication.
                      By default, the URI is composed of 
                      remote_ip:remote_port.

   -sf filename     : Loads an alternate xml scenario file.
                      To learn more about XML scenario syntax,
                      use the -sd option to dump embedded 
                      scenarios. They contain all the necessary
                      help.

   -sn name         : Use a default scenario (embedded in
                      the sipp executable). If this option is omitted,
                      the Standard SipStone UAC scenario is loaded.
                      Available values in this version:

                        'uac'      : Standard SipStone UAC (default).
                        'uac_pcap' : Standard SipStone UAC with pcap
                                     play (RTP)
                        'uas'      : Simple UAS responder.
                        'regexp'   : Standard SipStone UAC - with
                                     regexp and variables.
                        'branchc'  : Branching and conditional
                                     branching in scenarios - client.
                        'branchs'  : Branching and conditional
                                     branching in scenarios - server.

                      Default 3pcc scanerios (see -3pcc option):

                        '3pcc-C-A' : Controller A side (must be started
                                     after all other 3pcc scenarios)
                        '3pcc-C-B' : Controller B side.
                        '3pcc-A'   : A side.
                        '3pcc-B'   : B side.
   -ip_field nr     : Set which field from the injection file contains the
                      IP address from which the client will send its
                      messages.
                      If this option is omitted and the '-t ui' option is
                      present, then field 0 is assumed.
                      Use this option together with '-t ui'

   -sd name         : Dumps a default scenario (embeded in
                      the sipp executable)

   -t [u1|un|ui|t1|tn|l1|ln] : Set the transport mode:

                        u1: UDP with one socket (default),
                        un: UDP with one socket per call,
                        ui: UDP with one socket per IP address
                            The IP addresses must be defined in the
                            injection file.
                        t1: TCP with one socket,
                        tn: TCP with one socket per call,
                        l1: TLS with one socket,
                        ln: TLS with one socket per call.

   -trace_msg       : Displays sent and received SIP messages in
                      <scenario file name>_<pid>_messages.log

   -trace_screen    : Dump statistic screens in the 
                      <scenario_name>_<pid>_screens.log file when
                      quitting SIPp. Useful to get a final status report
                      in background mode (-bg option).

   -trace_timeout   : Displays call ids for calls with timeouts in
                      <scenario file name>_<pid>_timeout.log

   -trace_stat      : Dumps all statistics in <scenario_name>_<pid>.csv
                      file. Use the '-h stat' option for a detailed
                      description of the statistics file content.

   -stf file_name   : Set the file name to use to dump statistics

   -trace_err       : Trace all unexpected messages in
                      <scenario file name>_<pid>_errors.log.

   -trace_logs      : Allow tracing of <log> actions in
                      <scenario file name>_<pid>_logs.log.

   -trace_rtt       : Allow tracing of all response times in
                      <scenario file name>_<pid>_rtt.csv.

   -rtt_freq freq   : freq is mandatory. Dump response times 
                      every freq calls in the log file defined 
                      by -trace_rtt. Default value is 200.

   -s service_name  : Set the username part of the resquest URI.
                      Default is 'service'.

   -ap password     : Set the password for authentication challenges.
                      Default is 'password'

   -tls_cert name   : Set the name for TLS Certificate file.
                      Default is 'cacert.pem'

   -tls_key name    : Set the name for TLS Private Key file.
                      Default is 'cakey.pem'

   -tls_crl name    : Set the name for Certificate Revocation List file.
                      If not specified, X509 CRL is not activated.

   -f frequency     : Set the statistics report frequency on screen
                      (in seconds). Default is 1.

   -fd frequency    : Set the statistics dump log report frequency
                      (in seconds). Default is 60.

   -l calls_limit   : Set the maximum number of simultaneous
                      calls. Once this limit is reached, traffic
                      is decreased until the number of open calls
                      goes down. Default:

                        (3 * call_duration (s) * rate).

   -m calls         : Stop the test and exit when 'calls' calls are
                      processed.

   -rtp_echo        : Enable RTP echo. RTP/UDP packets received
                      on port defined by -mp are echoed to their
                      sender.
                      RTP/UDP packets coming on this port + 2
                      are also echoed to their sender (used for
                      sound and video echo).

   -mp media_port   : Set the local RTP echo port number. Default
                      is 6000.

   -mi local_rtp_ip : Set the local media IP address.

   -mb buf_size     : Set the RTP echo buffer size (default: 2048).

   -3pcc ip:port    : Launch the tool in 3pcc mode ("Third Party
                      call control"). The passed ip address
                      is depending on the 3PCC role.
                      - When the first twin command is 'sendCmd' then
                      this is the address of the remote twin socket.
                      Example: 3PCC-C-A scenario.
                      - When the first twin command is 'recvCmd' then
                      this is the address of the local twin socket.
                      Example: 3PCC-C-B scenario.

   -nr              : Disable retransmission in UDP mode.

   -max_retrans     : Maximum number of UDP retransmissions before call
                      ends on timeout.
                      Default is 5 for INVITE transactions and 7 for
                      others.

   -nd              : No Default. Disable all default behavior of SIPp
                      which are the following:
                      - On UDP retransmission timeout, abort the call by
                      sending a BYE or a CANCEL
                      - On unexpected BYE send a 200 OK and close the call
                      - On unexpected CANCEL send a 200 OK and close the call
                      - On unexpected PING send a 200 OK and continue the call
                      - On any other unexpected message, abort the call by
                      sending a BYE or a CANCEL

   -rsa host:port   : Set the remote sending address to host:port.
                      for sending the messages.

   -max_reconnect   : Set the the maximum number of reconnection.

   -aa              : Enable the automatic answer for the INFO message.

Signal handling:

   SIPp can be controlled using posix signals. The following signals
   are handled:
   USR1: Similar to press 'q' keyboard key. It triggers a soft exit
         of SIPp. No more new calls are placed and all ongoing calls
         are finished before SIPp exits.
         Example: kill -SIGUSR1 732
   USR2: Triggers a dump of all statistics screens in
         <scenario_name>_<pid>_screens.log file. Especially useful 
         in background mode to know what the current status is.
         Example: kill -SIGUSR2 732

Exit code:

   Upon exit (on fatal error or when the number of asked calls (-m
   option) is reached, sipp exits with one of the following exit
   code:
    0: All calls were successful
    1: At least one call failed
   97: exit on internal command. Calls may have been processed
   99: Normal exit without calls processed
   -1: Fatal error


Example:

   Run sipp with embedded server (uas) scenario:
     ./sipp -sn uas
   On the same host, run sipp with embedded client (uac) scenario
     ./sipp -sn uac 127.0.0.1
]]>
          </source>
        </section>
    </section>
    <anchor id="perf" /><section><title>Performance testing with SIPp</title>
      <section><title>Advices to run performance tests with SIPp</title>
        <p>SIPp has been originally designed for SIP performance testing. Reaching 
        high call rates and/or high number of simultaneous SIP calls is possible
        with SIPp, provided that you follow some guidelines:</p>
        <ul>
          <li>Use an HP-UX, Linux or other *ix system to reach high performances. 
          The Windows port of SIPp (through CYGWIN) cannot handle high performances.</li>
          <li>Limit the traces to a minimum (usage of -trace_msg, -trace_logs
          should be limited to scenario debugging only)</li>
          <li>To reach a high number of simultaneous calls in multi-socket mode,
          you must increase the number of filedescriptors handled by your system. Check
          "<a href="#filedesc">Increasing File Descriptors Limit</a>" section for more details.</li>
          <li>Understand <a href="#scheduling">internal SIPp's scheduling mechanism</a> 
          and use the -timer_resol, -max_recv_loops and -up_nb command
          line parameters to tune SIPp given the system it is running on.</li>
        </ul>
        <p>Generally, running performance tests also implies measuring response
        times. You can use SIPp's timers (start_rtd, rtd in scenarios and -trace_rtt
        command line option) to measure those response times. The precision of those
        measures are entirely dependent on the timer_resol parameter
        (as described in "<a href="#scheduling">SIPp's internal scheduling</a>"
        section). You might want to use another "objective" method if 
        you want to measure those response times with a high precision (a tool
        like <a href="http://www.wireshark.org/">Wireshark</a> will allow you to do so).</p>
      </section>
      <anchor id="scheduling" /><section><title>SIPp's internal scheduling</title>
        <p>Three parameters can be set to allow SIPp to benefit of the
        hardware it is running on. Tuning those parameters will also reduce the risk
        of unwanted retransmissions at high call rates.</p>
        <p>Let's first describe SIPp's main scheduling loop:</p>
        <source><![CDATA[+-->---+
|      | 
|    Management of new calls (creation of new calls if needed ...):
|      | ->done every time 
|      |
|    Management of ongoing calls (calculate wait, retransmissions ...): 
|      | ->done every "timer_resol" ms at best
|      |
|    Management of received messages: 
|      | ->done every time, "max_recv_loops" messages are read at the very most
|      |
|    Management of statistics: 
|      | ->done every time
|      |
+--<---+]]></source>

        <p>Several parameters can be specified on the command line to fine tune
        this scheduling.</p>
        <ul>
          <li>timer_resol:
            during the main loop, the management of calls (management of wait,
            retransmission ...) is done for all calls, every "timer_resol" ms at
            best. The delay of retransmission must be higher than "timer_resol".
            This parameter can be reduce to reduce retransmissions. If other
            treatments in SIPp are too long, "timer_resol" can not be respected.
            Reduce "max_recv_loops" to reduce retransmissions.</li>
          <li>max_recv_loops and up_nb:
            received messages are read and treated in batch. "max_recv_loops" is the
            maximum number of messages that can be read at one time. During this
            treatment, internal clock ("clock_tick") is updated every
            "max_recv_loops/up_nb" read messages. For heavy call rate, reduce
            "max_recv_loops" and/or increase "up_nb" to limit the retransmissions.
            Be careful, those two parameters have a large influence on the CPU
            occupation of SIPp.</li>
         </ul>
      </section>
    </section>
    <section><title>Useful tools aside SIPp</title>
        <section><title>JEdit</title>
            <p>JEdit (<a href="http://www.jedit.org/">http://www.jedit.org/</a>) is a
            GNU GPL text editor written in Java, and available on almost all
            platforms. It's extremely powerful and can be used
            to edit SIPp scenarios with syntax checking if you put the DTD 
            (<a href="http://sipp.sourceforge.net/doc/sipp.dtd">sipp.dtd</a>)
            in the same directory as your XML scenario.</p>
        </section>
        <section><title>Wireshark/tshark</title>
            <p>Wireshark (<a href="http://www.wireshark.org/">http://www.wireshark.org/</a>) is a
            GNU GPL protocol analyzer. It was formerly known as Ethereal. It supports SIP/SDP/RTP.</p>
            <p></p>
        </section>
        <section><title>SIP callflow</title>
            <p>When tracing SIP calls, it is very useful to be able 
            to get a call flow from an wireshark trace. The "callflow" tool allows you to do 
            that in a graphical way:
            <a href="http://callflow.sourceforge.net/">http://callflow.sourceforge.net/</a></p>
            <p>An equivalent exist if you want to generate HTML only call flows
            <a href="http://www.iptel.org/~sipsc/">http://www.iptel.org/~sipsc/</a></p>
        </section>
    </section>
    <section><title>Getting support</title>
        <p>You can likely get email-based support from the sipp users community. The mailing list address is 
        <a href="mailto:sipp-users@lists.sourceforge.net">sipp-users@lists.sourceforge.net</a>.
        To protect you from SPAM, this list is restricted (only people that actually subscribed can
        post). Also, you can browse the SIPp mailing list archive: 
        <a href="http://lists.sourceforge.net/lists/listinfo/sipp-users">http://lists.sourceforge.net/lists/listinfo/sipp-users</a></p>
    </section>
    <section><title>Contributing to SIPp</title>
        <p>Of course, we welcome contributions! If you created a feature 
        for SIPp, please send the "diff" output 
        (<code>diff -bruN old_sipp_directory new_sipp_directory</code>)
        so that it can be integrated in SIPp.</p>
    </section>
  </body>
</document>
